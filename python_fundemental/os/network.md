# NetWork
- Unix 网络编程
- Linux 编程手册

## Questions

### 1. TCP/IP分别在模型的哪一层， 简单介绍下7层模型;

`图解TCP/IP`

### 2. 三次握手和四次挥手(为什么是三次, 不是四次)
`https://www.zhihu.com/question/271701044/answer/398114686`
`https://zhuanlan.zhihu.com/p/40013850` -- 面试参考题
`unix 网络编程`
- 三次握手
~~~
    (1) 第一次握手：建立连接时，客户端A发送SYN包(SYN=j)到服务器B，并进入SYN_SEND状态，等待服务器B确认。
    (2) 第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK=j+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态。
    (3) 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK=k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
    完成三次握手，客户端与服务器开始传送数据
~~~
- 四次挥手
~~~
    1.首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭
    
~~~

- 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
~~~
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
~~~



### 3. TCP/UDP区别，和适用场景？

`图解TCP/IP`

>1. 面向连接vs无连接, TCP 有三次握手的连接过程，UDP 适合消息的多播发布，从单个点向多个点传输消息可靠性
>2. TCP 利用握手， 确认（ACK） 和重传的机制，提供了可靠性保证，而 UDP 可能丢失，不知道到底有没有接收
>3. 有序性：TCP 利用序列号保证了消息包的的顺序交付，到达可能无序，但 TCP 会排序
>4. 速度：TCP 速度比较慢，因为要创建连接，保证消息的可靠性和有序性等，需要做额外的很多事情，UDP 更适合对速度比较敏感的应用，比如在线视频媒体, 多人在线游戏等。

### 4. 

### 5. 画出http协议的格式

`csapp上第十一章，简洁明了`
- http 请求:
~~~
    1. 第一部分: 第一行是起始行
        method URI version
    2. 第二部分: 起始行后面是零个或者多个请求报头(首部字段), 最后要以一个空的文本行来终止报头;
    3. 空行之后就是报文主体(body): 可选

    GET / HTTP/1.1
    Host: www.baidu.com
    Accept: text/*
    
~~~

- http 响应:
~~~
    1. 只是起始行的与请求行不同;
        version status-code status-message

    HTTP/1.1 200 OK
    Content-Type: text/html
    Content-Length: 14592

    <html>
        ...
    </html>
~~~

### 6. restful介绍
`http://blog.jobbole.com/112710/`
- 就是用URL定位资源，用HTTP描述操作;
- REST即Representational State Transfer的缩写，可译为"表现层状态转化”。REST最大的几个特点为：资源、统一接口、URI和无状态。
    - 资源：它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。
    - 统一接口： 数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。
    - uri： 可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。
    - 无状态：所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。

        1. 在无状态的Web服务中，每一个Web请求都必须是独立的，请求之间是完全分离的。Server没有保存Client的状态信息，所以Client发送的请求必须包含有能够让服务器理解请求的全部信息，包括自己的状态信息。使得一个Client的Web请求能够被任何可用的Server应答，从而将Web系统扩展到大量的Client中。

        2. 有状态和无状态的区别，举个简单的例子说明一下。如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的，因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行；如果输入一个url即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个url与之对应，可以通过HTTP中的GET方法得到资源，这是典型的RESTful风格。



### 7. 如何实现断点续传

### 8. tcp和ip包头常见有哪些字段

`图解TCP/IP`

### 9、tcp粘包是怎么回事，如何处理？udp有粘包吗？
- TCP协议是面向流的协议，这也是容易出现粘包问题的原因。
- 而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。

例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束

所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

### 10、http连接方式。get和post的区别， 还有其他方法熟悉不？

- get, post, put, head, delete
- options: 请求服务器告知其支持的方法

### 11. 使用http状态码处理错误

~~~
    200 – OK – 一切正常
    201 – created – 新的资源已经成功创建
    202 — accepted 请求已经接受，但服务器还没有对其执行任何动作
    204 – No Content 响应首部包含若干首部和一个状态行， 但没有实体的主体部分，主要用与在浏览器不转为显示新文档的情况下，对其进行更新
    304 – Not Modified – 客户端使用缓存数据

    400 – Bad Request – 请求无效，需要附加细节解释如 "JSON无效"
    401 – Unauthorized – 请求需要用户验证
    403 – Forbidden – 服务器已经理解了请求，但是拒绝服务或这种请求的访问是不允许的。
    404 – Not found – 没有发现该资源

    405 — 该url不支持这种方法
    502 – Bad GateWay 作为代理或者网关使用的服务器从请求响应链的下一条链路收到了一条伪响应

    500 – Internal Server Error – API开发者应该避免这种错误。
~~~

### 12. 为什么网络层（IP）和链路层（mac）都需要地址
`P307， 自顶向下`

### 13、A与B建立了正常连接后，从未相互发过数据，这个时候B突然机器重启，问A此时的tcp状态处于什么状态？如何消除服务器程序中的这个状态？
`Unix 网络编程`

### 14、time_wait是什么情况？
`Linux 系统编程手册61.6.7`
- time wait的目的
~~~
    1.确保能可靠地中止连接--当最后的ack丢失时, 2msl保证,1msl留给最后的ack到达对端, 1msl留给可能会重新发送的fin报文;
    2.确保老的重复的报文失效;
~~~

### 15、阻塞和非阻塞socket在send、recv函数上的行为表现，异步connect函数的写法？
`Unix 网络编程`

### 16、一些socket选项的用法，nagle / keepalive / linger等选项的区别

### 17. 

### 18. https的建立链接过程, https的传输数据是否是对称加密， https的证书在哪颁发
`https://www.aneasystone.com/archives/2016/04/java-and-https.html`

### 19. TCP如何保证数据的可靠传输的（子问题延伸，拥塞控制慢开始、拥塞避免快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）
`停止等待协议、连续ARQ协议、滑动窗口、流量控制、拥塞控制（慢开始、拥塞避免、快重传、快恢复）`
`https://coolshell.cn/articles/11564.html`

### 20. nginx如何处理连接
`https://zhuanlan.zhihu.com/p/67636582`

### 21. nginx如何做性能优化

### 22. Nginx超时怎么办
### **23. 讲下重定向**
- 当访问http://facebook.com/, 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.facebook.com/” 而非“http://facebook.com/”

- 为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？
~~~
    其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.igoro.com/ 和http://igoro.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。

    还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。
~~~

### **24. 浏览器访问, 越详细越好**
`https://www.zhihu.com/question/34873227`
`https://blog.csdn.net/iamxiaoguizi/article/details/51175506`
`http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/`
`https://juejin.im/entry/588b23308fd9c5f5478c477e` -- 第七步的详细解读

`http://fex.baidu.com/blog/2014/05/what-happen/`
`貌似这一片就够了`
~~~
    第一步，域名解析

    第二步，向着服务器发起HTTP请求

    第三步，请求走网络，到达服务器所在机房的交换机

    第四步，数据走几层交换机之后，到达服务器网卡

    第五步，网卡数据经过OS，到达Nginx

    第六步，Nginx收到HTTP请求

    第七步，Nginx调用ThinkPHP框架(这里假定是这个框架)

    第八步，PHP连接Mysql数据库获取数据

    第九步，PHP处理数据

    第十步，Nginx返回数据到用户端

    第十一步，用户端浏览器完整接收数据之后，渲染完毕
~~~
>1. 第一步: 当 URL 输入浏览器时, 浏览器的第一步是通过访问的域名找出其IP地址, 而这就是dns的主要任务, DNS(Domain Name System)提供的服务就是将域名转换成其服务器IP地址, DNS查找过程如下：
~~~
    浏览器缓存 – 浏览器会缓存DNS记录一段时间;

    系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用。这样便可获得系统缓存中的记录;

    路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存;

    ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录;

    本地DNS服务器把查询报文转发到根DNS服务器，该根DNS服务器注意到其com后缀并向本地DNS服务器返回com的顶级域名服务器的IP地址。该本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其http://baidu.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地域名服务器将含有http://baidu.com的IP地址的响应报文发送给客户端主机;
~~~

>2. 第二步: 浏览器给web服务器发送一个HTTP请求
~~~
    http协议的格式: 参考题5;
    以get, post举例, 捎带讲下cookie(参考27题), 以及重定向(参考23题)
    如果问起, 可以讲下https(参考28题)

    在应用层和传输层之间，更准确地讲是在浏览器进程和操作系统提供的TCP服务程序之间，有一个很重要的东西叫做套接字（Socket）,TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址和目的端口号）来标识的。
        - 套接字的作用是实现传输层的多路复用和多路分解(自顶向下P126)。在应用层可以同时运行多个进程，每个进程都需要通过传输层来收发分组，而传输层的TCP进程只有一个，当TCP进程收到一个分组后，该怎么确定应该转发给哪个进程呢？答案是通过套接字，这就是多路分解。同样的道理，多路复用就是进程将分组通过各自的套接字转发给传输层。
~~~

>3. 第三, 四, 五步: not that important...
~~~

~~~

### **25. 简单讲讲 DNS **
`自顶向下P88`
- DNS具有两层含义：
~~~
    ①一个由分层的DNS服务器实现的分布式数据库；有三种类型的DNS服务器：根DNS服务器、顶级DNS服务器和权威DNS服务器。
    ②一个允许主机查询分布式数据库的应用层协议。
~~~

- 主要作用:
~~~
    将用户提供的主机名解析为IP地址;
~~~

- 详解:
~~~
    1. 运行在UDP之上, 使用的端口53;

    2. 有三种类型的DNS服务器：
        a.根DNS服务器: 
        b.顶级DNS服务器: 顶级域名如.com, .org, .net, .edu
        c.权威DNS服务器: 多数大学和大公司实现和维护自己的权威DNS服务器;

    3. 还有一类重要的DNS，称为本地DNS服务器

注解: ISP即互联网服务提供商;
~~~

- DNS 记录和报文:
`自顶向下P93`
~~~

~~~

### **26. 讲讲URL后面加/的含义**
- to be finished
- “http://facebook.com/”中的斜杠是至关重要的。这种情况下，浏览器能安全的添加斜杠。而像“http: //example.com/folderOrFile”这样的地址，因为浏览器不清楚folderOrFile到底是文件夹还是文件，所以不能自动添加 斜杠。这时，浏览器就不加斜杠直接访问地址，服务器会响应一个重定向，结果造成一次不必要的握手;

### **27. 谈谈cookie**
- 

### **谈谈https**
`https://zhuanlan.zhihu.com/p/22142170`
`https://www.zhihu.com/question/21518760/answer/19698894`
- 此两篇文章足以

### **28. 端口**
`https://zhuanlan.zhihu.com/p/20365900`

###**29. 服务端调用accept()之前，如果服务端sleep(),客服端connect()是否成功**
`以下几个问题都可以从UNP 第六章找到答案`
###**30. **

###**31. 客户端连接成功后，如果服务器sleep(),客户端发送send(),是否可以成功**

###**32. **

### **33. 出现过多的close_wait可能是什么原因**
- 程序问题：说的具体一点，服务器端的代码，没有写 close 函数关闭 socket 连接，也就不会发出 FIN 报文段；或者出现死循环，服务器端的代码永远执行不到 close。
- 客户机响应太慢或者 timeout 设置过小

#### **34. http头部，keepalive的意义**
#### **35. 跨域的方法**
#### **36. 各层对应的网络设备（路由器、交换机、网关、网桥、集线器等等），各层对应的协议**
#### **37. IP地址分类，子网划分（笔试常用）**
#### **38. HTTP1.0和HTTP1.1区别**
#### **39. Https怎么防止被抓包**
#### **40. **
#### **41. http中如果想要使用缓存, 需要设置哪些字段**
#### **42. 服务端如果告诉客户端可以使用缓存会返回什么状态码？服务端错误又是什么状态码？如果是服务端代理问题的又是什么状态码**
#### **43. 如何实现多个网站之间共享登录状态**
#### **44. IPV4 的地址有多少位, 多少个字节, IPV6的呢?**
#### **45. ARP协议是什么**
#### **46. 对称加密和非对称加密有什么区别, 有哪些应用?**



#### **47. time_wait大量出现的原因, 如何避免这种问题？**


18. TCP最后一次ACK包没有送到就开始传输数据包，会发生什么？

>服务端不会接受数据包，并且会返回给客户端RST包，也就是异常包

#### **48.UDP传输数据的最大容量？为什么？**

#### **49. Ping命令做了什么？基于那一个层？ping是哪一个层的？**
- 应用层，使用ICMP协议，没有使用TCP/IP

#### **50. 每次DNS域名解析都要请求DNS服务器，是不是很耗时？怎么解决**
#### **51. 看cup某个进程使用率为百分之五十，什么意思？使用率是怎么算出来的？**
#### **52. HTTP1.0， HTTP1.1和 HTTP2.0的区别**

> HTTP2.0支持二进制传输数据，更加安全快捷，而 HTTP1.0， HTTP1.1支持文本

> HTTP2.0实现多路复用，更加快捷

> HTTP2.0压缩header

> HTTP2.0支持服务“主动”给客户端缓存发送数据

#### **53. 如何避免浏览器缓存**
#### **54. 如何理解HTTP协议的无状态性**
#### **55. http状态码301和302详解及区别**
~~~
官方的比较简洁的说明：

        301 redirect: 301 代表永久性转移(Permanently Moved)

        302 redirect: 302 代表暂时性转移(Temporarily Moved )

        ps:这里也顺带记住了两个比较相近的英语单词（permanently、temporarily），嘻哈！



        详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。





      这里开启傻瓜自问自答模式（自己可能想到的疑问）：

1、什么是重定向啊？

        就是地址A跳转到地址B啦。百度百科的解释：重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。



2、可是，为什么要进行重定向啊？什么时候需要重定向呢？

        想跳就跳，就跳的漂亮。还是借鉴百度百科：

1）网站调整（如改变网页目录结构）；
2）网页被移到一个新地址；
3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。
        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

3、那么，什么时候进行301或者302跳转呢？
        当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。
    清晰明确而言：
使用301跳转的场景：
1）域名到期不想续费（或者发现了更适合网站的域名），想换个域名。
2）在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。
3）空间服务器不稳定，换空间的时候。

使用302跳转的场景：
        --尽量使用301跳转！

~~~
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**

`======================此段为Unix网络编程笔记=====================================`
#### **1. 三次握手和四次挥手的具体实现细节**
`5.6节--5.7节`
- 三次握手
    (1)客户端调用socket 和 connect函数, connect函数引起TCP的三路握手过程, 当三路握手都完成后, 客户端的connect和服务端的accept都返回,连接建立,当服务端的accept返回时,服务器调用fork, 子进程再进行相关的处理. 父进程再次调用accept并阻塞, 等待下一个客户连接;

- 四次挥手 (以客户端主动中止为例)
    (1)客户端进程中止时, 内核会关闭该进程中所有打开的文件描述符,这会导致客户端TCP发送一个FIN给服务器, 服务器则报以ACK响应, 至此, 服务器端进入CLOSE_WAIT状态, 客户端套接字进入FIN_WAIT_2状态;
    (2)当服务器TCP接受FIN时, 服务器子进程阻塞于readline调用, 于是readline返回0,子进程函数调用完成, 服务器子进程中所有打开的文件描述符随之关闭,同时触发服务端TCP发送终止序列的最后两个分节: 服务器端发送FIN, 客户端回应ACK, 至此, 连接完全终止, 客户套接字进入TIME_WAIT状态;

#### **2. TCP输出**
`2.11.1 TCP输出`
- 应用进程写数据到一个TCP套接字时的步骤：
    （1）每一个套接字有一个发送缓冲区， 当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的缓冲区（如果该套接字的发送缓冲区容不下该应用进程的所有的数据， 该应用进程将被投入睡眠， 此处假设该套接字是阻塞的（此为默认设置））；
    （2）内核将不从write系统调用返回， 直到应用进程缓冲区中的所有数据都被复制到套接字缓冲区；
    （3）从写一个TCP 套接字的write调用返回成功仅表示我们可以重新使用原来的应用进程缓冲区， 并不代表对端的TCP或应用进程已经接收到数据；

#### **3.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**

`================================================================================`
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**