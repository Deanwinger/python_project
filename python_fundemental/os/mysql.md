## MySQL

~~~
    explain结果中的type字段。你的查询中分别是：
    1.type: index 
    解释：index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。

    2.type: ref
    ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。
~~~


#### **1. MySQL锁有几种；死锁是怎么产生的；数据库乐观锁使用**

- 1 两种类型的锁:

~~~
    (1)共享锁(读锁) 
        读锁共享，多个客户在同一时刻可以同时读取资源,而互不干扰；
    (2)排他锁(写锁)
        写锁排他，一个写锁会阻塞其他的写锁和读锁；
    
    锁粒度(两种最重要的锁策略)
    (1)表锁
        最基本的锁策略, 开销小
    (2)行级锁
        行级锁只在存储引擎层实现，
~~~

- 2 死锁：指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象， 为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制，当死锁发生时，只有部分或者完全回滚其中的一个事务，才能打破死锁；

- 3 乐观锁，悲观锁

~~~
    (1) 乐观锁
    乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

    读取：事务将数据读入缓存，这时系统会给事务分派一个时间戳。

    校验：事务执行完毕后，进行提交。这时同步校验所有事务，如果事务所读取的数据在读取之后又被其他事务修改，则产生冲突，事务被中断回滚。

    写入：通过校验阶段后，将更新的数据写入数据库。

    乐观并发控制多数用于数据争用不大、冲突较少的环境中（读多写少的应用场景），这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。

    乐观锁一般来说有以下2种方式：

    A. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

    B. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

    (2)悲观锁
    悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

    悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

    悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
~~~


#### **2. varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符**

1. 主要区别：

~~~
    (1).char是一种长度固定的类型, varchar 长度可变；
    (2).char列检索出来的值，尾部空格会被删除，varchar会被保留；
    ()()()()()
~~~

2. 大小限制：
    - char(M), 0<=M<=255, 默认为1；
    - varchar(M) 1<=M<=65535, varchar列通茶需要1或者2个额外的字节记录字符串的长度，当列长度小于255，使用一个字节记录，否则两个；适合场景：
        - a.字符串的最大长度比平均长度大很多;
        - b.列更新很少;
        - c.使用了像utf-8这样复杂的字符集(每个字符都使用不同的字节数进行存储）；

3. 存多少
    - 声明为char的列长度是固定的,char的长度可选范围在0-255之间.也就是char最大能存储`255个字符`.如果该列是utf8编码,则该列所占用的字节数=字符数*3.如果是gbk编码则该列所占用的字节数=字符数*2

    - 采用varchar类型存储数据需要1-2个字节(长度超过255时需要2个字节)来存储字符串的实际长度.如果该列的编码为gbk,每个字符最多占用2个字节,最大长度不能超过32766个字符.如果该列的编码为utf8,每个字符最多占3个字节,最大字符长度为21845（21844）.

#### **3. 如果查询很慢，你会想到的第⼀个⽅式是什么？**

1. 方式：

    (1). 是否向数据库请求了不需要的数据
    - 查询不需要的记录
    - 多表关联时返回全部的列
    - 总是取出全部的列
    - 重复查询相同的数据

    (2). MySQL是否在扫描额外的记录
    - 最简单的衡量查询开销的的三个指标：
        - 响应时间： 服务时间(查询真正所花时间）和排队时间（等待某些资源而没有真正执行查询的时间--可能是等IO操作完成，也可能是等待行锁）, 响应时间手很多方面的影响，比如存取引擎的锁，高并发资源竞争，硬件响应等, 用 快速上限估计法来估计查询的响应时间；
            - 快速上限估计法：了解这个查询需要哪些索引以及他的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以具体硬件条件下一次IO的消耗时间，最后累加, 就可以获得一个大概的参考值；
        - 扫描的行数和访问类型：
            - explain语句中的type列反应了访问类型，访问类型有很多种, 从全表扫描到索引扫描、范围扫描、唯一索引扫描、常数引用等；这些列出来的， 速度按从慢到快, 扫描的行数也是按从大到小；
            - explain的Extra，using where时, 一般MySQL能够使用如下三种方式应用where条件， 从好到坏依次是：
                - 在索引中使用where条件来过滤不匹配的记录， 这是在存储引擎层完成的；
                - 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录。直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层中完成的， 但无需再回表查询记录
                - 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）， 这是在MySQL服务器层完成， MySQL需要先从数据表读出记录然后过滤；


        - 扫描的行数和返回的行数：理想的是两者==

#### **4.索引有什么用，大致原理是什么？索引的优点，代价（缺点），设计索引有什么注意点？**
`1.索引有什么用`

- 加速查询

`2. 索引的原理`

- 一种高效的数据结构， 通常使用BTree实现， 还有哈希索引，全文索引等其他索引

`3.索引的优点`

- 大大减少服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变成顺序IO(1，顺序IO不需要多次磁盘寻道，2不需额外的排序操作)

`4。索引的代价`

- 加快检索， 但是降低了索引列的插入， 删除和更新值的速度， 对于写操作较多的表来说， 在索引更新方面的开销会非常大；

- 索引占据更大的空间；
    a. MYISAM 表，对于大量的索引， 有可能导致索引文件比数据文件更快的到达其limit；
    b. Innodb系统表空间里的所有InnoDB表， 都共享同一个存储空间池（数据和索引集中存储在同一个文件）， 添加索引会使表空间里用于存储的空间减少的更快， 加速到达文件的limit；

`5.设计索引的注意要点`

- 为用于搜索，排序或分组的列创建索引，也就是说，最佳索引列是那些出现在where 子句，连接子句，或者是出现在order by或 GROUP BY子句中的列；

- 认真考虑数据列的基数，列的基数是指它所容纳的所有非重复值的个数，通常来说，列的基数越高（包含的唯一值多， 重复值少）索引的效果越好；

- 索引值短小，对于InnoDB更有好处，主键值会在每一个二级索引（把主键值和二级索引值存储在一起）中重复出现，因此，如果主键值越长，则会导致每一个二级索引越大；

- 索引字符串的前缀, 想要对字符串列进行索引, 应当尽量指定前缀长度；

- 利用最左前缀，当创建包含n个列的复合索引时，实际上会创建n个专供MySQL使用的索引，复合索引修当于多个索引， 因为索引中最左边的任意数据列集合都可以用于匹配(参考14题， 复合索引结构)

- 不要建立过多的索引：1.每增加一个索引, 需要额外的磁盘空间，2.更新操作,需相应的更新索引（P205）,3索引太多时，将无法使用最好的索引（增加查询优化的工作）

- 让参与比较的索引类型保持匹配 ：散列索引不适合做范围查找

- 尽可能使用索引覆盖查询；

`总结`

- 编写查询语句时，应该尽可能选择合适的索引以避免单行查找、尽可能使用原生顺序从而避免额外的排序操作， 并尽可能的使用索引覆盖查询

#### **6. 了解Join吗，有几种**

- 技术内幕P97

- 内连接和外连接
~~~
    - 内连接只会显示在两个表里都匹配上的行；
    - 外连接还可以把其中一个表在另一个表里没有匹配的行也显示出来， 以NULL显示；
~~~

#### **索引有几类， BTree与Hash索引的区别**
- 高性能MySQL5.1.1

- B-Tree，Hash， 空间索引（R-Tree），全文索引，其他索引

#### **数据库的隔离级别，一定会产生幻读吗？怎么解决**
- DDIA 第九章


#### **11. mysql in，not in,like走不走索引**

- to be finished

#### **14. 复合索引的结构**

- 链接 `https://www.zhihu.com/question/36996520`

- mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于 `实现了类似order by name cid`这样一种排序规则， 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。

- 那么什么时候才能用到呢?当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4  5。这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。

#### **16. 怎么看是否⽤到了某个索引？**

#### **17. like %aaa%会使⽤索引吗? like aaa%呢? (技术内幕P208)**

- %aaa%不会， aaa%会

#### **18. drop、truncate、delete的区别？**

#### **20. 数据库中事物的特征？**（ACID）

- 事务就是一组原子性的sql查询，或者说是一个独立的单元；

- start transaction 开始一个事务，要么使用commit，要么使用Rollback撤销；

~~~
    - A 原子性：一个事务必须被视为一个不可分割的最小单位，要么全部执行，要么全部不执行；

    - C 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态（两个账户之间的balance不会失衡）；

    - I 隔离性：一个事务在提交前，对其他事务是不可见的；

    - D 持久性：一旦事务提交，则其所做的修改会永久的保存在数据库中；
~~~

#### **22. primary key 和 unique key 的区别**

- 技术内幕P86

- 每个表只包含一个primary key， 可以有多个unique key；

- pk 不能包含NULL值，unique行，（NULL值不与任何值相等，甚至是另一个NULL值）

