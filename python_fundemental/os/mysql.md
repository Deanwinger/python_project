## MySQL

#### **1. MySQL锁有几种；死锁是怎么产生的；数据库乐观锁使用**

- 1 两种类型的锁:

~~~
    (1)共享锁(读锁) 
        读锁共享，多个客户在同一时刻可以同时读取资源,而互不干扰；
    (2)排他锁(写锁)
        写锁排他，一个写锁会阻塞其他的写锁和读锁；
    
    锁粒度(两种最重要的锁策略)
    (1)表锁
        最基本的锁策略, 开销小
    (2)行级锁
        行级锁只在存储引擎层实现，
~~~

- 2 死锁：指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象， 为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制，当死锁发生时，只有部分或者完全回滚其中的一个事务，才能打破死锁；

- 3 乐观锁，悲观锁

~~~
    (1) 乐观锁
    乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

    读取：事务将数据读入缓存，这时系统会给事务分派一个时间戳。

    校验：事务执行完毕后，进行提交。这时同步校验所有事务，如果事务所读取的数据在读取之后又被其他事务修改，则产生冲突，事务被中断回滚。

    写入：通过校验阶段后，将更新的数据写入数据库。

    乐观并发控制多数用于数据争用不大、冲突较少的环境中（读多写少的应用场景），这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。

    乐观锁一般来说有以下2种方式：

    A. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

    B. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

    (2)悲观锁
    悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

    悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

    悲观并发控制实际上是“先取锁再访问”的保守策略[1]，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
~~~


#### **2. varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符**

1. 主要区别：

~~~
    (1).char是一种长度固定的类型, varchar 长度可变；
    (2).char列检索出来的值，尾部空格会被删除，varchar会被保留；
    ()()()()()
~~~

2. 大小限制：
    - char(M), 0<=M<=255, 默认为1；
    - varchar(M) 1<=M<=65535, varchar列通茶需要1或者2个额外的字节记录字符串的长度，当列长度小于255，使用一个字节记录，否则两个；适合场景：
        - a.字符串的最大长度比平均长度大很多;
        - b.列更新很少;
        - c.使用了像utf-8这样复杂的字符集(每个字符都使用不同的字节数进行存储）；

3. 存多少
    - 声明为char的列长度是固定的,char的长度可选范围在0-255之间.也就是char最大能存储`255个字符`.如果该列是utf8编码,则该列所占用的字节数=字符数*3.如果是gbk编码则该列所占用的字节数=字符数*2

    - 采用varchar类型存储数据需要1-2个字节(长度超过255时需要2个字节)来存储字符串的实际长度.如果该列的编码为gbk,每个字符最多占用2个字节,最大长度不能超过32766个字符.如果该列的编码为utf8,每个字符最多占3个字节,最大字符长度为21845（21844）.

#### **3. 如果查询很慢，你会想到的第⼀个⽅式是什么？**

1. 方式：

    (1). 是否向数据库请求了不需要的数据
    - 查询不需要的记录
    - 多表关联时返回全部的列
    - 总是取出全部的列
    - 重复查询相同的数据

    (2). MySQL是否在扫描额外的记录
    - 最简单的衡量查询开销的的三个指标：
        - 响应时间： 服务时间(查询真正所花时间）和排队时间（等待某些资源而没有真正执行查询的时间--可能是等IO操作完成，也可能是等待行锁）, 响应时间手很多方面的影响，比如存取引擎的锁，高并发资源竞争，硬件响应等, 用 快速上限估计法来估计查询的响应时间；
            - 快速上限估计法：了解这个查询需要哪些索引以及他的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以具体硬件条件下一次IO的消耗时间，最后累加, 就可以获得一个大概的参考值；
        - 扫描的行数和访问类型：
            - explain语句中的type列反应了访问类型，访问类型有很多种, 从全表扫描到索引扫描、范围扫描、唯一索引扫描、常数引用等；这些列出来的， 速度按从慢到快, 扫描的行数也是按从大到小；
            - explain的Extra，using where时, 一般MySQL
        - 扫描的行数和返回的行数：理想的是两者==

#### **4.索引是⼲嘛的?**