# MySQL

## Questions

~~~
    explain结果中的type字段。你的查询中分别是：
    1.type: index 
    解释：index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。

    2.type: ref
    ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。
~~~

#### **1. MySQL锁有几种；死锁是怎么产生的；数据库乐观锁使用**

- 1 两种类型的锁:

~~~
    (1)共享锁(读锁) 
        读锁共享，多个客户在同一时刻可以同时读取资源,而互不干扰；
    (2)排他锁(写锁)
        写锁排他，一个写锁会阻塞其他的写锁和读锁；
    
    锁粒度(两种最重要的锁策略)
    (1)表锁
        最基本的锁策略, 开销小
    (2)行级锁
        行级锁只在存储引擎层实现，
~~~

- 2 死锁：指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象， 为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制，当死锁发生时，只有部分或者完全回滚其中的一个事务，才能打破死锁；

- 3 乐观锁，悲观锁

~~~
    (1) 乐观锁
    乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

    读取：事务将数据读入缓存，这时系统会给事务分派一个时间戳。

    校验：事务执行完毕后，进行提交。这时同步校验所有事务，如果事务所读取的数据在读取之后又被其他事务修改，则产生冲突，事务被中断回滚。

    写入：通过校验阶段后，将更新的数据写入数据库。

    乐观并发控制多数用于数据争用不大、冲突较少的环境中（读多写少的应用场景），这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。

    乐观锁一般来说有以下2种方式：

    A. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

    B. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

    (2)悲观锁
    悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

    悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

    悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
~~~


#### **2. varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符**

1. 主要区别：

~~~
    (1).char是一种长度固定的类型, varchar 长度可变；
    (2).char列检索出来的值，尾部空格会被删除，varchar会被保留；
    ()()()()()
~~~

2. 大小限制：
    - char(M), 0<=M<=255, 默认为1；
    - varchar(M) 1<=M<=65535, varchar列通茶需要1或者2个额外的字节记录字符串的长度，当列长度小于255，使用一个字节记录，否则两个；适合场景：
        - a.字符串的最大长度比平均长度大很多;
        - b.列更新很少;
        - c.使用了像utf-8这样复杂的字符集(每个字符都使用不同的字节数进行存储）；

3. 存多少
    - 声明为char的列长度是固定的,char的长度可选范围在0-255之间.也就是char最大能存储`255个字符`.如果该列是utf8编码,则该列所占用的字节数=字符数*3.如果是gbk编码则该列所占用的字节数=字符数*2

    - 采用varchar类型存储数据需要1-2个字节(长度超过255时需要2个字节)来存储字符串的实际长度.如果该列的编码为gbk,每个字符最多占用2个字节,最大长度不能超过32766个字符.如果该列的编码为utf8,每个字符最多占3个字节,最大字符长度为21845（21844）.

#### **3. 如果查询很慢，你会想到的第⼀个⽅式是什么？**

1. 方式：

    (1). 是否向数据库请求了不需要的数据
    - 查询不需要的记录
    - 多表关联时返回全部的列
    - 总是取出全部的列
    - 重复查询相同的数据

    (2). MySQL是否在扫描额外的记录
    - 最简单的衡量查询开销的的三个指标：
        - 响应时间： 服务时间(查询真正所花时间）和排队时间（等待某些资源而没有真正执行查询的时间--可能是等IO操作完成，也可能是等待行锁）, 响应时间手很多方面的影响，比如存取引擎的锁，高并发资源竞争，硬件响应等, 用 快速上限估计法来估计查询的响应时间；
            - 快速上限估计法：了解这个查询需要哪些索引以及他的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以具体硬件条件下一次IO的消耗时间，最后累加, 就可以获得一个大概的参考值；
        - 扫描的行数和访问类型：
            - explain语句中的type列反应了访问类型，访问类型有很多种, 从全表扫描到索引扫描、范围扫描、唯一索引扫描、常数引用等；这些列出来的， 速度按从慢到快, 扫描的行数也是按从大到小；
            - explain的Extra，using where时, 一般MySQL能够使用如下三种方式应用where条件， 从好到坏依次是：
                - 在索引中使用where条件来过滤不匹配的记录， 这是在存储引擎层完成的；
                - 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录。直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层中完成的， 但无需再回表查询记录
                - 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）， 这是在MySQL服务器层完成， MySQL需要先从数据表读出记录然后过滤；


        - 扫描的行数和返回的行数：理想的是两者==

#### **4.索引有什么用，大致原理是什么？索引的优点，代价（缺点），设计索引有什么注意点？**
`1.索引有什么用`

- 加速查询

`2. 索引的原理`

- 一种高效的数据结构， 通常使用BTree实现， 还有哈希索引，全文索引等其他索引

`3.索引的优点`

- 大大减少服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变成顺序IO(1，顺序IO不需要多次磁盘寻道，2不需额外的排序操作)

`4。索引的代价`

- 加快检索， 但是降低了索引列的插入， 删除和更新值的速度， 对于写操作较多的表来说， 在索引更新方面的开销会非常大；

- 索引占据更大的空间；
    a. MYISAM 表，对于大量的索引， 有可能导致索引文件比数据文件更快的到达其limit；
    b. Innodb系统表空间里的所有InnoDB表， 都共享同一个存储空间池（数据和索引集中存储在同一个文件）， 添加索引会使表空间里用于存储的空间减少的更快， 加速到达文件的limit；

`5.设计索引的注意要点`

- 为用于搜索，排序或分组的列创建索引，也就是说，最佳索引列是那些出现在where 子句，连接子句，或者是出现在order by或 GROUP BY子句中的列；

- 认真考虑数据列的基数，列的基数是指它所容纳的所有非重复值的个数，通常来说，列的基数越高（包含的唯一值多， 重复值少）索引的效果越好；

- 索引值短小，对于InnoDB更有好处，主键值会在每一个二级索引（把主键值和二级索引值存储在一起）中重复出现，因此，如果主键值越长，则会导致每一个二级索引越大；

- 索引字符串的前缀, 想要对字符串列进行索引, 应当尽量指定前缀长度；

- 利用最左前缀，当创建包含n个列的复合索引时，实际上会创建n个专供MySQL使用的索引，复合索引修当于多个索引， 因为索引中最左边的任意数据列集合都可以用于匹配(参考14题， 复合索引结构)

- 不要建立过多的索引：1.每增加一个索引, 需要额外的磁盘空间，2.更新操作,需相应的更新索引（P205）,3索引太多时，将无法使用最好的索引（增加查询优化的工作）

- 让参与比较的索引类型保持匹配 ：散列索引不适合做范围查找

- 尽可能使用索引覆盖查询；

`总结`

- 编写查询语句时，应该尽可能选择合适的索引以避免单行查找、尽可能使用原生顺序从而避免额外的排序操作， 并尽可能的使用索引覆盖查询

#### **5. 外键有什么用，是否该用外键？外键一定需要索引吗？**

- 技术内幕2.13

`1. 有什么用`

- 利用外键关系，可以在一个表里声明‘与另一个表里的某个列相关联的‘列
- A foreign key is a constraint, a relationship between two tables - that has nothing to do with an index 

`2. 是否该用外键`
~~~
1. 互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；

2.传统行业
    1>.软件应用的人数有限，换句话说是可控的；
    2>.数据库服务器的数据量也一般不会超大，且活跃数据有限；

综合上述2句话描述，也即数据库服务器的性能不是问题，所以不用过多考虑性能的问题；另外，使用外键可以降低开发成本，借助数据库产品自身的触发器可以实现表与关联表之间的数据一致性和更新；最后一点，使用外键的方式，还可以做到开发人员和数据库设计人员的分工，可以为程序员承担更多的工作量；

为何说外键有性能问题：
1.数据库需要维护外键的内部管理；
2.外键等于把数据的一致性事务实现，全部交给数据库服务器完成；
3.有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；
4.外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；
~~~

`3. 外键要索引吗？`

- 虽然不会自动创建， 还是建议安装上索引， 便于查找


#### **6. 了解Join吗，有几种**

`技术内幕P97`

- 内连接和外连接

~~~
    - 内连接只会显示在两个表里都匹配上的行；
    - 外连接还可以把其中一个表在另一个表里没有匹配的行也显示出来， 以NULL显示；
~~~

#### **7. 索引有几类， BTree与Hash索引的区别**

`高性能MySQL5.1.1`

- B-Tree，Hash， 空间索引（R-Tree），全文索引，其他索引

#### **8. innodb的两阶段锁定协议是什么情况？**

`DDIA 第七章事务两阶段锁定`
`https://en.wikipedia.org/wiki/Two-phase_locking`

- 在数据库系统领域，并发控制机制主要有两种，即锁和多版本机制。

- 两阶段锁是一种所谓的悲观并发控制机制(pessimistic):它是基于这样的原则:如果有事情可能出错(如另一个事务所持有的锁所表示的),最好等到情况安全后再做任何事情。这就像互斥,用于保护多线程编程中的数据结构。

#### **9. 数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别**

#### **10. 数据库的隔离级别，一定会产生幻读吗？怎么解决**

- 9,10 为同一题

`DDIA 第七章事务, 全章总结`
~~~
    术语解释：
        脏写：如果两个事务同时尝试更新数据库中的相同对象，会发生什么情况？我们不知道写入的顺序是怎样的，但是我们通常认为后面的写入会覆盖前面的写入。但是，如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作脏写
~~~

1. 四种隔离级别
- read uncommitted（读未提交）
    - 在此种隔离级别，可能出现脏读（一个事务读取另一个事务的未被执行的写入）
- read commited （提已交读）
    - 满足隔离性的简单定义：一个事务开始时，只能看见已经提交的事务的所做的修改，也就是说，一个事务从开始到提交之前，所做的任何改变对其他的事务是不可见的， 也叫“不可重复读”， 因为两次执行同样的查询，可能得到不一样的结果；
- repeatable read (可重复读)
    - 解决了脏读的问题，该级别保证了同一个事务中多次读取同样的记录， 结果是一样的，但是有可能导致`幻读`(指的是，当某个事务在读取某个范围内的记录时，另一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行)，InnoDB通过MVCC解决了幻读的问题;
- serialization （可串行化）
    - 会在读取的每一行数据上都加锁； 最高级别，强制事务串行执行，避免了幻读的问题，

2. 弱隔离级别：
- 读未提交（Read uncommitted）：它可以防止脏写，但不防止脏读

- 读已提交 
    >1. 它提供了两个保证：

        （1）从数据库读时，只能看到已提交的数据（没有脏读）
        （2）从数据库写时，只会覆盖已写入的数据（没有脏写）

    >2. 实现读已提交：

        （1）防止脏写，最常见的情况是：数据库通过使用“行锁”来防止脏写：当事务想要修改特定对象，它必须首先获得该对象的锁，然后必须持有该锁直到事务被提交或者中止，一次只有一个事务可以持有任何给定对象的锁；如果另一个事务要写入同一个对象，必须等到第一个事务提交或者是中止后，才能获得该锁并继续；

        （2）防止脏读，对于写入的每个对象，数据库都会记住旧的已提交值，和当前写入的新值，当事务在正在进行时，任何其他读取对象的事务都会拿到旧值；

- 快照隔离和可重复读
    >1. 在读已提交的隔离条件下，不可重复读被认为是可以接受的，然后还是会有场景不能忍受这种，比如：

        - 备份
        - 分析查询和完整性检查

    >2. 快照隔离是这个问题的最常见的解决方案：
    
        每个事务都从数据库的“一致快照”中读取，也就是说，事务可以看到事务开始时在数据库中提交的所有数据，即使这个数据随后被另外的事务修改，每个事务只能看到该特定时间点的旧数据；

    >3. 实现快照隔离：
        - 通常使用写锁来防止脏写，快照隔离的一个关键原则：读不阻塞写，写不阻塞读；


#### **11. mysql in，not in,like走不走索引**

- to be finished

#### **12. 索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效**

#### **13. 数据库有哪些锁（乐观锁悲观锁），select时怎么加排它锁**

#### **14. 复合索引的结构**

`https://www.zhihu.com/question/36996520`

- mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于 `实现了类似order by name cid`这样一种排序规则， 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。

- 那么什么时候才能用到呢?当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4  5。这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。

#### **15. 如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上这个索引？查三列呢？MySQL为什么使用B+树作为索引？如果where条件后⾯带有⼀个 i + 5 < 100 会使⽤到这个索引吗？**

         (1)如果是第一列, 是可以的, 因为MySQL索引查询规则,(高性能MySQL)P145
         (2)P146, 索引查找限制
         where条件
         (1)P146, 限制的第三条
         需点出:a: 如果有违反了三条限制的任一条, 则不能使用索引

#### **16. 怎么看是否⽤到了某个索引？**

#### **17. like %aaa%会使⽤索引吗? like aaa%呢? **

`技术内幕P208`

- %aaa%不会， aaa%会

#### **18. drop、truncate、delete的区别？**

#### **19. 你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?**

#### **20. 数据库中事物的特征？**（ACID）

`DDIA 第七章`

- 事务就是一组原子性的sql查询，或者说是一个独立的单元；

- start transaction 开始一个事务，要么使用commit，要么使用Rollback撤销；

~~~
    - A 原子性：一个事务必须被视为一个不可分割的最小单位，要么全部执行，要么全部不执行；

    - C 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态（两个账户之间的balance不会失衡）；

    - I 隔离性：同时执行的事务是相互隔离的，一个事务在提交前，对其他事务是不可见的；

    - D 持久性：一旦事务提交，则其所做的修改会永久的保存在数据库中；
~~~

- 存储引擎一个几乎普遍的目标：对单节点上的单个对象（例如键值对）上提供原子性和隔离性，原子性可以通过使用日志来实现崩溃恢复，并且可以使用每个对象上的锁来实现隔离；一些数据库也提供更复杂的原子操作。同样流行的是`比较和设置（CAS, compare-and-set）`操作，当值没有并发被其他人修改过时，才允许执行写操作。这些单对象操作很有用，因为它们可以防止在多个客户端尝试同时写入同一个对象时丢失更新；

~~~
    术语解释：
    1. CAS
    2. 丢失更新
~~~


#### **21. mysql的引擎,区别与适用场景。Innodb 和 MyISAM 的区别**

#### **22. primary key 和 unique key 的区别**

`技术内幕P86`

- 每个表只包含一个primary key， 可以有多个unique key；

- pk 不能包含NULL值，unique行，（NULL值不与任何值相等，甚至是另一个NULL值）

#### **23. 为何，以及如何分区、分表；**

#### **24. NoSQL了解么，和关系数据库的区别**

`技术内幕2.6.2.5`
`InnoDB引擎4.9`

#### **25. 存储过程的优点**

（1）.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 

（2）.当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 

（3）.存储过程可以重复使用,可减少数据库开发人员的工作量。 

（4）.安全性高,可设定只有某此用户才具有对指定存储过程的使用权。

#### **26. 如何实现数据库的原子性，可以用伪代码实现吗**

#### **27. 如果有很多数据插⼊MYSQL 你会选择什么⽅式?（一个数据库，每十分钟会接收到百万级的数据进行插入，应该怎么设计？）**

#### **28. 在极端情况下，系统缓存全部失效，该如何防止流量全部打到数据库上**

`缓存重建问题`

#### **29. 数据库三范式**

`https://www.zhihu.com/question/24696366`

#### **30. 手写sql练习题**
`https://www.zhihu.com/question/19552975`