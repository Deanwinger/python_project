# Python Fundation

## Questions
- 参考 `https://zhuanlan.zhihu.com/p/39914177`

#### **1. 手写：正则邮箱地址**

- to be finished

#### **2. 可变与不可变类型**

- 

#### **3. Python是如何进行内存管理的**

- 从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制
~~~
一、对象的引用计数机制

    python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

    引用计数增加的情况：

        1，一个对象分配一个新名称

        2，将其放入一个容器中（如列表、元组或字典）

    引用计数减少的情况：

        1，使用del语句对对象别名显示的销毁

        2，引用超出作用域或被重新赋值

    sys.getrefcount( )函数可以获得对象的当前引用计数

    多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。

二、垃圾回收

    1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。

    2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。

三、内存池机制

    Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

    1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

    2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

    3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
~~~

#### **4. range()函数**

- iterator

#### **5. 以装饰器的方式实现单例模式,使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别**

#### **6. 以装饰器的方式实现单例模式**

#### **7. 写一个简单的python socket编程**

#### **8. 浅拷贝与深拷贝**

#### **9. 列表推导list comprehension和生成器的优劣**

#### **10. 介绍下装饰器**

#### **11. 介绍下协程，为何比线程还快**

#### **12. 强类型/弱类型和静态类型/动态类型**

#### **13. 手写多线程买票代码**

#### **14. python最常见的解释器**

#### **15. python中map、filter的使用**

#### **16. 知道GIL的限制以及与多线程的关系**

#### **17. python中dict的底层实现，以及与OrderDict的关系, dict和UserDict的关系，为什么有UserDict的存在**

#### **18. python多继承的查找规则（MRO）**

#### **19. property的含义以及其描述器实现**

#### **20. __slots__的含义以及使用场景**

#### **21. 如何定义和使用元类，了解其使用场景**

#### **22. python中type和object之间的关系**

#### **23. python中的打包方式（setup.py）**

#### **24. PEP8常见的范式,至少列举5个**

#### **25. 鸭子类型（duck typing）的含义与其在python中的表现形式**

#### **26. asyncio的使用方式和使用场景**

#### **27. WSGI协议是什么**

#### **28. 如何利用collections，itertools，operator等模块来高效地操作容器对象。**

#### **29. python中序列化的常用库和接口（json，pickle）**

#### **30. StringIO和BytesIO的用途。**

#### **31. 单下划线开头、双下划线开头和双下划线包围的变量分别代表着什么含义**

#### **32. __init__和__new__方法在class和type中分别的作用是什么**

#### **33. 类变量和实例变量的区别**

#### **34. __dict__在类中的含义，以及类属性和方法与__dict__的关系**

#### **35. python中生成器的实现以及其使用场景**

#### **36. python中抽象类的实现方式，以及其抽象基类模块，如何用python类实现一个抽象容器类型。**

#### **37. classmethod和staticmethod的区别**

#### **38. 装饰器中添加functools.wraps的含义与作用**

#### **39. __getattr__和__getattribute__的作用以及其顺序关系**

#### **40. python中性能测量的方式，如cProfile，tracemalloc**

#### **41. python中自省的使用方式，知道inspect库的常见用法**

#### **42. sys.settrace和sys.setprofile在python中的用途和使用方式**

#### **43. python中的模块定义，以及导入模块的各种姿势**

#### **44. global和local关键字在python中的含义和其使用场景**

#### **45. for-else，try-else的含义和用途**

#### **46. .pyc文件的含义，清楚python代码大概的执行过程**

#### **47. python中格式化字符串的方式以及其常见格式语法**

#### **48. python中常见的魔术方法和其使用方式**

#### **49. 描述符**

#### **50. python递归的最大层数**

#### **51. *arg和**kwarg作用**

#### **52. 参数的延迟绑定**

#### **53. 正则的贪婪匹配**

#### **54. 你对闭包的理解**

#### **55. os和sys模块的作用**

#### **56. 如何判断是函数还是方法**

#### **57. GIL锁**
#### **58. Python中如何使用线程池和进程池**
#### **59. threadlocal的作用**
#### **60. 简述 asynio模块的作用和应用场景**
#### **61. 33简述 gevent模块的作用和应用场景**
#### **62. twisted框架的使用和应用**
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **





