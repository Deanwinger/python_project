# Python Fundation

## Questions
- 参考 `https://zhuanlan.zhihu.com/p/39914177`

#### **1. 手写：正则邮箱地址**

- to be finished

#### **2. 可变与不可变类型**

- 可变: 
    - list, dict, 如果要进一步, bytearray,memoryview, array.array, collection.deque(待了解)
    ~~~
        dict 的变种(Fluent Python 3.5):
            (1). collections.OrderedDict: 这个类型在添加键的时候会保持顺序

            (2). collections.ChainMap: 该类型可以容纳数个不同的映射对象,然后在进行键查找操作的时候,
                 这些对象会被当作一个整体被逐个查找,直到键被找到为止。

            (3). collections.Counter: 这个映射类型会给键准备一个整数计数器。每次更新一个键的时候
                 都会增加这个计数器。所以这个类型可以用来给可散列表对象计数.

            (4). colllections.UserDict: 这个类其实就是把标准 dict 用纯 Python 又实现了一遍, UserDict 是让用户继承写子类的
    ~~~

- 不可变:
    - tuple, str, bytes

#### **3. Python是如何进行内存管理的**

- 从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制
~~~
一、对象的引用计数机制

    python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

    引用计数增加的情况：

        1，一个对象分配一个新名称

        2，将其放入一个容器中（如列表、元组或字典）

    引用计数减少的情况：

        1，使用del语句对对象别名显示的销毁

        2，引用超出作用域或被重新赋值

    sys.getrefcount( )函数可以获得对象的当前引用计数

    多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。

二、垃圾回收

    1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。

    2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。

三、内存池机制

    Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

    1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

    2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

    3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
~~~

#### **4. 可迭代对象, 迭代器, 生成器**

`Fluent Python 第14章: 可迭代的对象, 迭代器和生成器`

- 迭代是数据处理的基石

>1. 可迭代对象
- 使用 iter 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 __iter__ 方法,那么对象就是可迭代的。序列都可以迭代;实现了 __getitem__ 方法,而且其参数是从零开始的索引,这种对象也可以迭代。
~~~
序列可以迭代的原因:
    iter函数,解释器需要迭代对象 x 时,会自动调用 iter(x), 内置的 iter 函数有以下作用:
        (1) 检查对象是否实现了 __iter__ 方法,如果实现了就调用它,获取一个迭代器。
        (2) 如果没有实现 __iter__ 方法,但是实现了 __getitem__ 方法,Python 会创建一个迭代器,
            尝试按顺序(从索引 0 开始)获取元素。
        (3) 如果尝试失败,Python 抛出 TypeError 异常,会提示“C object is not iterable”(C 对象不可迭代),
            其中 C 是目标对象所属的类。
~~~

>2. 迭代器
- 可迭代的对象和迭代器之间的关系:Python 从可迭代对象中获取迭代器。

- 迭代器:实现了无参数的 __next__ 方法,返回序列中的下一个元素;如果没有元素了,那么抛出 StopIteration 异常。Python 中的迭代器还实现了 __iter__ 方法,因此迭代器也可以迭代。
~~~
    标准的迭代器接口有两个方法。
        __next__
        返回下一个可用的元素,如果没有元素了,抛出 StopIteration异常;

        __iter__
        返回 self,以便在应该使用可迭代对象的地方使用迭代器,例如在 for 循环中;
~~~

>3. 生成器
- Python有两种不同的方式提供生成器:
~~~
    1. 生成器表达式
    2. 生成器函数: 使用 yield 关键字的函数或方法; 调用生成器函数返回的是生成器对象; 跟普通函数不同的是，生成器只能用于迭代操作;

    - 根据我的经验,选择使用哪种句法:如果生成器表达式要分成多行写,我倾向于定义生成器函数,以便提高可读性。此外,生成器函数有名称,因此可以重用。
~~~
- 语法解释
~~~
    (1). 语法上和函数类似：生成器函数和常规函数几乎是一样的。它们都是使用def语句进行定义，差别在于，
         生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值
    (2). 自动实现迭代器协议：对于生成器，Python会自动实现迭代器协议，以便应用到迭代背景中（如for循环）。
         由于生成器自动实现了迭代器协议，所以，我们可以调用它的next方法，在没有值可以返回的时候，生成器自动产生StopIteration异常状态
    (3). 挂起：生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，
         以便之后从它离开的地方继续执行
~~~
#### **5. 介绍下装饰器**
`Fluent Python 第七章`

#### **6. 以装饰器的方式实现单例模式,使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别**

#### **7. 写一个简单的python socket编程**
~~~
# 首先，创建一个基于IPv4和TCP协议的Socket：

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 监听端口,小于1024的端口号必须要有管理员权限才能绑定：
s.bind(('127.0.0.1', 9999))

#紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：
s.listen(5)
print('Waiting for connection...')

#接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:
while True:
    # 接受一个新连接:
    sock, addr = s.accept()
    # 创建新线程来处理TCP连接:
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()

# 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
def tcplink(sock, addr):
    print('Accept new connection from %s:%s...' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode('utf-8') == 'exit':
            break
        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
    sock.close()
    print('Connection from %s:%s closed.' % addr)

~~~

#### **8. 浅拷贝与深拷贝**
`Fluent Python第八章`
- 每个变量都有标识、类型和值。对象一旦创建,它的标识绝不会变;你可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识;id() 函数返回对象标识的整数表示, 而变量名, 不过是给每个对象贴的标签;
~~~
    (1). 对象 ID 的真正意义在不同的实现中有所不同。在 CPython 中,id() 返回对象的内存地址,但是在其他 Python 解释器中可能是别的值。
    (2). is 运算符比 == 速度快,因为它不能重载,所以 Python 不用寻找并调用特殊方法,而是直接比较两个整数 ID
~~~

- Python 集合(列表、字典、元组,等等)一样,保存的是对象的引用;

- 默认做浅复制, 复制列表(或多数内置的可变集合)最简单的方式是使用内置的类型构造方法。
~~~
    浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数}
    
    深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数}
~~~

#### **9. 列表推导和生成器的优劣**

- 列表推导式一次性产生全部需要的值;
- 生成式是惰性求值, 而且只遍历一遍;

#### **10. 弱引用**
`Fluent Python 8.6 弱引用`


#### **11. 介绍下协程，为何比线程还快**
`Fluent Python 第16章`
- 协程就是一种用户态内的上下文切换技术
- 协程使用生成器函数定义:定义体中有 yield 关键字
- to be finished

- 从句法上看,协程与生成器类似,都是定义体中包含 yield 关键字的函数。可是,在协程中,yield 通常出现在表达式的右边(例
如,datum = yield),可以产出值,也可以不产出——如果 yield关键字后面没有表达式,那么生成器产出 None。协程可能会从调用方
接收数据,不过调用方把数据提供给协程使用的是 .send(datum) 方法,通常,调用方会把值推送给协程。

>16.1 生成器如何进化成协程
~~~
    生成器的调用方可以使用 .send(...) 方法发送数据,发送的数据会成为生成器函数中 yield 表达式的值。因此,生成器可以作为协程使用。协程是指一个过程,这个过程与调用方协作,产出由调用方提供的值。
~~~

>16.2 用作协程的生成器的基本行为
~~~
    协程可以身处四个状态中的一个。当前状态可以使用inspect.getgeneratorstate(...) 函数确定,该函数会返回下述字
    符串中的一个: 

    'GEN_CREATED' -- 等待开始执行。
    
    'GEN_RUNNING' -- 解释器正在执行, 只有在多线程应用中才能看到这个状态。

    'GEN_SUSPENDED' -- 在 yield 表达式处暂停。
    
    'GEN_CLOSED' -- 执行结束。
~~~

>16.3 示例:使用协程计算移动平均值
~~~
    def averager():
        total = 0.0
        count = 0
        average = None

        while True:
            term = yield average
            total += term
            count += 1
            average = total / count
~~~

>16.4 预激协程的装饰器
~~~
    from functools import wraps

    def coroutine(func):
        """装饰器:向前执行到第一个`yield`表达式,预激`func`"""
        @wraps(func)
        def primer(*args,**kwargs):
            gen = func(*args,**kwargs) 
            next(gen) 
            return gen
        return primer
~~~

>16.5 终止协程和异常处理
>16.6 让协程返回值
~~~
    生成器对象会抛出 StopIteration 异常。异常对象的 value 属性保存着返回的值。

    return 表达式的值会偷偷传给调用方,赋值给 StopIteration异常的一个属性。这样做有点不合常理,但是能保留生成器对象的常规行为——耗尽时抛出 StopIteration 异常。
~~~

#### **12. 强类型/弱类型和静态类型/动态类型**

#### **13. 手写多线程买票代码**

#### **14. python最常见的解释器**

#### **15. python中map, filter, reduce的使用**

- 在 Python 3 中,map 和 filter 都是内置函数, 返回生成器(一种迭代器),但是由于引入了列表推导和生成器表达式,它们变得没那么重要了。列表推导或生成器表达式具有 map 和 filter 两个函数的功能
~~~
    map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

    和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
~~~

- reduce
~~~
    1. 在 Python 2 中,reduce 是内置函数,但是在 Python 3 中放到functools 模块里了,reduce() 函数的第一个参数是接受两个参数的函数,第二个参数是一个可迭代的对象。假如有个接受两个参数的 fn 函数和一个 lst 列表。调用reduce(fn, lst) 时,fn 会应用到第一对元素上,即 fn(lst[0], lst[1]),生成第一个结果 r1。然后,fn 会应用到 r1 和下一个元素上,即 fn(r1, lst[2]),生成第二个结果 r2。接着,调用 fn(r2,lst[3]),生成 r3......直到最后一个元素,返回最后得到的结果 rN

    2. 使用reduce函数时最好提供第三个参数,reduce(function, iterable, initializer),这样能避免这个异常:TypeError: reduce() of empty sequence with no initial value(这个错误消息很棒,说明了问题,还提供
    了解决方法)。如果序列为空,initializer 是返回的结果;否则,在归约中使用它作为第一个参数,因此应该使用恒等值。
    比如,对 +、| 和 ^ 来说, initializer 应该是 0;而对 * 和 & 来说,应该是 1。
~~~

#### **16. 知道GIL的限制以及与多线程的关系**
`廖雪峰`
`Fluent Python 17.2 阻塞型I/O和GIL`
`Fluent Python 17.5.3 线程和多进程的替代方案`

#### **17. python中dict的底层实现，以及与OrderDict的关系, dict和UserDict的关系，为什么有UserDict的存在**
`Fluent Python 3.9--dict和set的背后`
- 散列表其实是一个稀疏数组(总是有空白元素的数组称为稀疏数组)。散列表里的单元通常叫作表元(bucket)。在 dict 的散列表当中,每个键值对都占用一个表元,每个表元都有两个部分,一个是对键的引用,另一个是对值的引用。Python 会设法保证大概还有三分之一的表元是空的,所以在快要达到这个阈值的时候,原有的散列表会被复制到一个更大的空间里面。

- 散列表算法:
~~~
为了获取 my_dict[search_key] 背后的值,Python 首先会调用hash(search_key) 来计算 search_key 的散列值,把这个值最低
的几位数字当作偏移量,在散列表里查找表元(具体取几位,得看当前散列表的大小)。若找到的表元是空的,则抛出 KeyError 异
常。若不是空的,则表元里会有一对 found_key:found_value。这时候 Python 会检验 search_key == found_key 是否为真,如
果它们相等的话,就会返回 found_value。

如果 search_key 和 found_key 不匹配的话,这种情况称为散列冲突。发生这种情况是因为,散列表所做的其实是把随机的元素映射到只有几位的数字上,而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突,算法会在散列值中另外再取几位,然后用特殊的方法处理一下,把新得到的数字再当作索引来寻找表元。 若这次找到的表元是空的,则同样抛出 KeyError;若非空,或者键匹配,则返回这个值;或者又发现了散列冲突,则重复以上的步骤。
~~~

- 优势和限制:
~~~
    (1). 键必须是可散列的, 一个可散列的对象必须满足以下要求:
        a. 支持 hash() 函数,并且通过 __hash__() 方法所得到的散列值是不变的。
        b. 支持通过 __eq__() 方法来检测相等性。
        c. 若 a == b 为真,则 hash(a) == hash(b) 也为真。
    (2). 字典在内存上的开销巨大
    (3). 键查询很快
~~~

#### **18. python多继承的查找规则（MRO）**
`Fluent Python 第12章--继承的优缺点`

#### **19. property的含义以及其描述器实现**
`Fluent Python 19.2`

#### **20. __slots__的含义以及使用场景**
`Fluent Python 9.8 使用 __slots__ 类属性节省空间`
- 默认情况下,Python 在各个实例中名为 __dict__ 的字典里存储实例属性。如 3.9.3 节所述,为了使用底层的散列表提升访问速度,字典会消耗大量内存。如果要处理数百万个属性不多的实例,通过 __slots__类属性,能节省大量内存,方法是让解释器在元组中存储实例属性,而不用字典。

- 在类中定义 __slots__ 属性的目的是告诉解释器:“这个类中的所有实例属性都在这儿了!”这样,Python 会在各个实例中使用类似元组的结构存储实例变量,从而避免使用消耗内存的 __dict__ 属性。如果有数百万个实例同时活动,这样做能节省大量内存。
~~~
    tips:
        1. 继承自超类的 __slots__ 属性没有效果。Python 只会使用各个类中定义的 __slots__ 属性;
        2. 实例只能拥有 __slots__ 中列出的属性, 除非把 '__dict__' 加入 __slots__ 中(这样做就失去了节省内存的功效);
        3. 如果不把 '__weakref__' 加入 __slots__,实例就不能作为弱引用的目标;
~~~

#### **21. 如何定义和使用元类，了解其使用场景**
`http://blog.jobbole.com/21351/`

#### **22. python中type和object之间的关系**

#### **23. python中的打包方式（setup.py）**
`Python高级编程 第五章--编写一个包`

#### **24. PEP8常见的范式,至少列举5个**
- Style Guide for Python Code
~~~
    一 代码编排
        1 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。
        2 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。
        3 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。

    二 文档编排
        1 模块内容的顺序：模块说明和docstring—import—globals&constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。
        2 不要在一句import中多个库，比如import os, sys不推荐。
        3 如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。

    三 空格的使用
        总体原则，避免不必要的空格。
        1 各种右括号前不要加空格。
        2 逗号、冒号、分号前不要加空格。
        3 函数的左括号前不要加空格。如Func(1)。
        4 序列的左括号前不要加空格。如list[2]。
        5 操作符左右各加一个空格，不要为了对齐增加空格。
        6 函数默认参数使用的赋值符左右省略空格。
        7 不要将多句语句写在同一行，尽管使用‘；’允许。
        8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。

    四 注释
        总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！
        注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。
        1 块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：
        # Description : Module config.
        # 
        # Input : None
        #
        # Output : None
        2 行注释，在一句代码后加注释。比如：x = x + 1	# Increment x
        但是这种方式尽量少使用。
        3 避免无谓的注释。

    五 文档描述
        1 为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。
        2 如果docstring要换行，参考如下例子,详见PEP 257
        """Return a foobang

        Optional plotz says to frobnicate the bizbaz first.

        """

    六 命名规范
        总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。
        1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。
        2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。
        3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。
        4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。
        5 异常命名使用CapWords+Error后缀的方式。
        6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是__all__机制;二是前缀一个下划线。
        7 函数命名使用全部小写的方式，可以使用下划线。
        8 常量命名使用全部大写的方式，可以使用下划线。
        9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。
        9 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。
        11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。
        12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。
        13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。
~~~

#### **25. 鸭子类型（duck typing）的含义与其在python中的表现形式**
`Fluent Python 10.3 协议和鸭子类型`

#### **26. Python dict的顺序**

#### **27. WSGI协议是什么**

#### **28. 如何利用collections，itertools，operator等模块来高效地操作容器对象。**
`问题太大, pass`

#### **29. python中序列化的常用库和接口（json，pickle）**
`廖雪峰 + Python 参考手册`

#### **30. StringIO和BytesIO的用途。**
`廖雪峰`

#### **31. 单下划线开头、双下划线开头和双下划线包围的变量分别代表着什么含义**
`Fluent Python 9.7 Python的私有属性和“受保护的”属性`

#### **32. __init__和__new__方法在class和type中分别的作用是什么**

#### **33. 类变量和实例变量的区别**

#### **34. __dict__在类中的含义，以及类属性和方法与__dict__的关系**
`Fluent Python 5.6 函数内省`

#### **35. python的模块间循环引用的问题，如何避免它**

#### **36. python中抽象类的实现方式，以及其抽象基类模块，如何用python类实现一个抽象容器类型。**
`Fluent Python 第 11 章`

#### **37. classmethod和staticmethod的区别**
`Fluent Python 9.4 classmethod与staticmethod`

#### **38. 装饰器中添加functools.wraps的含义与作用**

#### **39. __getattr__和__getattribute__的作用以及其顺序关系**
`Fluent Python 10.5--动态存取属性, 第19章--动态属性和特性, 19.6.3--处理属性的特殊方法`
- __getattr__
- 
~~~
    __getattr__(self, name)
    仅当获取指定的属性失败,搜索过 obj、Class 和超类之后调用。表达式 obj.no_such_attr、getattr(obj, 'no_such_attr') 和hasattr(obj, 'no_such_attr') 可能会触发Class.__getattr__(obj, 'no_such_attr') 方法,但是,仅当在obj、Class 和超类中找不到指定的属性时才会触发。

    __getattribute__(self, name)
    尝试获取指定的属性时总会调用这个方法,不过,寻找的属性是特殊属性或特殊方法时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 __getattribute__ 方法且抛出 AttributeError异常时,才会调用 __getattr__ 方法。为了在获取 obj 实例的属性时不导致无限递归,__getattribute__ 方法的实现要使用
    super().__getattribute__(obj, name)。
~~~

#### **40. python中性能测量的方式，如cProfile，tracemalloc**

#### **41. python中自省的使用方式，知道inspect库的常见用法**
`Fluent Python 5.8 获取关于参数的信息`

#### **42. sys.settrace和sys.setprofile在python中的用途和使用方式**

#### **43. python中的模块定义，以及导入模块的各种姿势**
`Python 参考手册`

#### **44. global和local关键字在python中的含义和其使用场景**\
`Fluent Python 7.4 变量作用域规则`

#### **45. for-else，try-else的含义和用途**
`Python参考手册`

#### **46. .pyc文件的含义，清楚python代码大概的执行过程**

#### **47. python中格式化字符串的方式以及其常见格式语法**
`印象笔记的收藏`

#### **48. python中常见的魔术方法和其使用方式**
`Fluent Python 第一章 1.2`

#### **49. 描述符**
`Fluent Python 第二十章`

#### **50. python递归的最大层数**
- python最大递归层数为1000层,通过setrecursionlimit函数来设置最大递归数, 以通过getrecursionlimit函数获取当前的递归层数

#### **51. *arg和**kwarg作用**

#### **52. 参数的延迟绑定**

#### **53. 正则的贪婪匹配**
`廖雪峰`

#### **54. 你对闭包的理解**
`Fluent Python 7.5 闭包`
- 简单来讲，一个闭包就是一个函数， 只不过在函数内部带上了一个额外的变量环境。闭包关键特点就是它会记住自己被定义时的环境。

#### **55. os和sys模块的作用**
`Python 参考手册`

#### **56. 如何判断是函数还是方法**

#### **57. 写一个类，并让它尽可能多的支持操作符**
#### **58. Python中如何使用线程池和进程池**
`Python 参考手册`
#### **59. threadlocal的作用**
`廖雪峰 + Python参考手册`
#### **60. 简述 asynio模块的作用和应用场景**
`Fluent Python第 18 章 使用 asyncio 包处理并发`
#### **61. 33简述 gevent模块的作用和应用场景**
#### **62. twisted框架的使用和应用**
#### **63. range()函数**
- python2：range 数字列表
    xrange 可迭代对象
- python3 ：可选迭代对象

#### **64. 函数的内省**
`Fluent Python 5.6`


#### **65. 解释一下python的and-or语法**
#### **66. hash表是怎么实现的？有冲突的时候怎么处理？**
#### **67. 线程安全是什么意思？新线程什么情况下会影响原有线程？**
#### **68. Python里面match()和search()的区别？**
- re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **
#### **. **





