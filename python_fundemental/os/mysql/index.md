# MySQL_INDEX
`索引相关`


#### **30. 聚簇索引**
- 定义:
~~~
    1. 主键索引, 既存储索引值, 又在叶子中存储行的数据;
    2. 没有主键, 会选择unique key 做主键;
    3. 如果没有unique key, 则会在内部生成一个rowid做主键;

    二级索引的叶子节点保存的不是指向行的物理位置的指针,而是行的主键值;
~~~

- 优势:
~~~
    1. 根据主键找, 效率高;
    2. 
~~~

- 劣势:
~~~
    0.最大限度的提高了IO密集型应用的性能, 但如果数据在内存中, 访问的顺序就不重要了,
    1.如果碰到主键不规则的数据插入, 容易造成频繁的页分裂(随之相伴的是大量的数据碎片);
    2.二级索引的访问需要两次索引的查找;
~~~

- 启发:
~~~
    使用InnoDB时,应该尽可能地按主键顺序插入数据;
~~~


#### **35. btree 索引**
`高性能Mysql5.1.1`
- BTree索引简介:
~~~
    1. BTree 索引意味着所有的值是按顺序存储的（很适合范围查找）， 并且每个叶子节点到根节点的距离相同；

    2. BTree 适用于全键值，键值范围, 键的最前缀查找, 精确匹配某一列并范围匹配另一列；
~~~

- BTree索引限制：
~~~
    1. 如果不是按照索引的最左列开始查找，则无法使用索引；

    2. 不能跳过中间的索引；

    3. 如果中间有某个列的范围查询，则右边所有的列都无法使用索引； 
~~~

#### **36. 哈希 索引**
`高性能Mysql5.1.1`
- 哈希索引简介:
~~~
    1. 基于哈希表实现,查询数据很快，只有精确匹配索引所有列的查询，才有效；

    2. 对每一行数据， 存储引擎都会对被索引的列计算一个哈希码， 哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存每个指向数据行的指针;

    3. 只有Memory索引支持哈希索引
~~~

- 哈希索引限制：
~~~
    1. 哈希索引只包含哈希值和行指针， 没有索引覆盖一说；

    2. 索引的数据并不是根据索引（数据）值顺序存储的， 所以无法用于排序；

    3. 不支持部分匹配列查找； 

    4. 哈希冲突多， 查询费事， 维护代价高；
~~~

#### **37. InnoDB的自适应哈希索引**
- InnoDB
~~~
高性能Mysql P148

    当InnoDB注意到某些索引值被使用的非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这是引擎自动和内部的行为，用户无法控制和配置；
~~~

#### **4.索引有什么用，大致原理是什么？索引的优点，代价（缺点）？**
- 1.索引有什么用
    - 加速查询, 特别是如果还涉及到分组和排序的话;

- 2.索引的原理
    - 一种高效的数据结构， 通常使用BTree实现， 还有哈希索引，全文索引等其他索引

- 3.索引的优点
    - 大大减少服务器需要扫描的数据量
    - 索引可以帮助服务器避免排序和临时表
    - 索引可以将随机IO变成顺序IO(1，顺序IO不需要多次磁盘寻道，2不需额外的排序操作)

- 4.索引的代价
    - 加快检索， 但是降低了索引列的插入， 删除和更新值的速度， 对于写操作较多的表来说， 在索引更新方面的开销会非常大；

    - 索引占据更大的空间；
        a. MYISAM 表，对于大量的索引， 有可能导致索引文件比数据文件更快的到达其limit；
        b. Innodb系统表空间里的所有InnoDB表， 都共享同一个存储空间池（数据和索引集中存储在同一个文件）， 添加索引会使表空间里用于存储的空间减少的更快， 加速到达文件的limit；


#### **38. 设计索引有什么注意点**
- 注意要点
~~~
    1. 为用于搜索，排序或分组的列创建索引，也就是说，最佳索引列是那些出现在where 子句，连接子句，或者是出现在order by或 GROUP BY子句中的列；

    2. 认真考虑数据列的基数，列的基数是指它所容纳的所有非重复值的个数，通常来说，列的基数越高（包含的唯一值多， 重复值少）索引的效果越好；

    3. 索引值短小，对于InnoDB更有好处，主键值会在每一个二级索引（把主键值和二级索引值存储在一起）中重复出现，因此，如果主键值越长，则会导致每一个二级索引越大；

    4. 索引字符串的前缀, 想要对字符串列进行索引, 应当尽量指定前缀长度；

    5. 利用最左前缀，当创建包含n个列的复合索引时，实际上会创建n个专供MySQL使用的索引，复合索引修当于多个索引， 因为索引中最左边的任意数据列集合都可以用于匹配(参考14题， 复合索引结构)

    6. 不要建立过多的索引：1.每增加一个索引, 需要额外的磁盘空间，2.更新操作,需相应的更新索引（P205）,3索引太多时，将无法使用最好的索引（增加查询优化的工作）

    7. 让参与比较的索引类型保持匹配 ：散列索引不适合做范围查找

    8. 尽可能使用索引覆盖查询；
~~~

#### **39. 高性能的索引策略**
`高性能MySQL 5.3`
>1. 独立的列： 索引列不能使表达式的一部分， 也不能是函数的参数；
>2. 前缀索引和索引选择性：
~~~
    a. 完整列的选择性： COUNT(DISTINCT city)/COUNT(*)， 不同值/总数
    b. 选择性要足够高，达到上述完整列的选择性即可（即前缀不能太长）；
    
    如何创建前缀索引：
    ALTER TABLE sakila.city_demo ADD KEY(city(7))
~~~
>3. 多列索引：
~~~
    a.此处主要讲了Mysql5.0之后引入了一种x新的策略--索引合并;
    b.索引合并有时候是一种优化的结果, 但实际上更多的时候说明了表上的索引建的很糟糕;
    c.如果再explain中看到有索引合并(extra列), 检查查询和表的结构;
~~~
>4. 选择合适的索引列顺序:
~~~
    a. 在一个多列B-Tree索引中, 索引列的顺序意味着索引首先按照最左列进行排序;
    b. 如何选择索引的顺序, 经验法则:
        (1). 当不需要考虑排序或者分组的时候: 将选择性最高的列放在索引的最前列(实际业务中, 需要根据查询频率做相应的调整)

~~~
>5. 聚簇索引
~~~
    - 参考题30
~~~
>6. 覆盖索引 
~~~
    - 参考题41
~~~
>7. 使用索引扫描来做排序
~~~
    - 参考题 46
~~~
>8. 压缩(前缀)索引
>9. 冗余和重复索引
>10. 未使用的索引
>11. 索引和锁


#### **41. 索引覆盖**
- 定义:
~~~
    如果一个索引包含所需要查询的字段的值, 就称之为覆盖索引;

    覆盖索引必须要存储索引列的值,只有BTree索引支持;
~~~
- 优势
~~~
    1. 索引条目小, 缓存负载小, 数据量大, 可能大部分时间都花在数据拷贝上了;
    2. MyISAM在内存中只缓存索引, 数据则依赖操作系统来缓存, 因此访问数据需要一次系统调用;
    3. 对InnoDB尤其有效, 可减少对主键索引的二次查询;
~~~

#### **2. 索引有几类， BTree与Hash索引的区别**
`高性能MySQL5.1.1`
- B-Tree，Hash， 空间索引（R-Tree），全文索引，其他索引


#### **46. 使用索引扫描做排序**
- 如果 explain 出来的type 列为 index, 说明mysql使用了索引扫描来做排序;
- 限制条件:
~~~
    1. 索引列的顺序和order by 子句的顺序完全一致;
    2. 如果需要关联多张表, 只有当ORDER BY子句引用的字段全部为第一个表时;
    3. 需要满足最左前缀的要求(有特例, P176);
~~~

#### **26. 如何实现数据库的原子性，可以用伪代码实现吗**
`加排他锁`
- 定义: 所谓原子操作是指不会被线程调度机制打断的操作;这种操作一旦开始,就一直运行到结束,中间不会有任何 context switch 线程切换


#### **55. MySQL为什么使用B+树作为索引**
`http://blog.codinglabs.org/articles/theory-of-mysql-index.html` -- 此文章非常值得一读
- B-树和B+树最重要的一个区别就是: B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域, 这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据;
~~~
    1. 一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。
    
    2. 另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问;
~~~

#### **84. 设置了索引但是无法使用的场景**
`高性能MySQL`
`TO BE FINISHED`