# MySQL_PARTITION
`分区相关`


#### **23. 为何，以及如何分区、分表；**
`结合DDIA一起看`
`http://blog.51yip.com/mysql/1029.html` -- mysql分表，分区的区别和联系

`http://blog.51yip.com/mysql/949.html`
>1 为何分表
~~~
    1. 当一张表的数据很大时， 查询耗时，分表的目的就在于减小数据库负担，缩短查询时间；
    2. mysql执行机制有行锁（Innodb），表锁（MyIsam），数据大之后的表锁不切实际；
~~~
>2.如何分表
~~~
    1.根据实际业务情况分，预先估计会出现大数据量并且访问频繁的表，将其分为若干个表：
        这种预估大差不差的，论坛里面发表帖子的表，时间长了这张表肯定很大，几十万，几百万都有可能。 聊天室里面信息表，几十个人在一起一聊一个晚上，时间长了，这张表的数据肯定很大。像这样的情况很多。所以这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。以聊天信息表为例：

        我事先建100个这样的表，message_00,message_01,message_02..........message_98,message_99.然后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，你可以用hash的方式来获得，可以用求余的方式来获得，方法很多，各人想各人的吧；


    2.利用merge存储引擎来实现分表
~~~

#### **43. 为何，以及如何分区**
`DDIA -- 第六章`
- 对于非常大的数据集,或非常高的吞吐量,仅仅进行复制是不够的:我们需要将数据进行分区(partitions),也称为分片(sharding);

- 一、键值数据的分区:
~~~
    a. 分区目标是将数据和查询负载均匀分布在各个节点上;
    b. 如果分区是不公平的;避免热点(不均衡导致的高负载的分区)最简单的方法是将记录随机分配给节点;此策略的缺点:当你试图读取一个特定的值时,你无法知道它在哪个节点上,所以你必须并行地查询所有的节点。
~~~
>1. 根据键的范围分区
~~~
    a. 为了均匀分配数据,分区边界需要依据数据调整,分区边界可以由管理员手动选择,也可以由数据库自动选择;
    b. 在每个分区中,我们可以按照一定的顺序保存键; 好处是进行范围扫描非常简单, 缺点是某些特定的访问模式会导致热点;
~~~

>2. 根据键的散列分区
~~~
    a. 许多分布式数据存储使用散列函数来确定给定键的分区;一旦你有一个合适的键散列函数,你可以为每个分区分配一个散列范围;
    b. 出于分区的目的,散列函数不需要多么强壮的加密算法:例如,Cassandra和MongoDB使用MD5;
    c. 分区边界可以是均匀间隔的,也可以是伪随机选择的(在这种情况下,该技术有时也被称为一致性哈希);
    
    缺点:
        失去了键范围分区的一个很好的属性:高效执行范围查询的能力;在MongoDB中,如果您使用了基于散列的分区模式,则任何范围查询都必须发送到所有分区;

    策略(DDIA P179):
        组合索引方法
        Cassandra中的表可以使用由多个列组成的复合主键来声明。键中只有第一列会作为散列的依据,而其他列则被用作Casssandra的SSTables中排序数据的连接索引;
        场景: 社交媒体, 一个用户可能发布多更新;如果更新的主键选择为(user_id, update_timestamp),那就可以有效的检索特定用户某个时间间隔内按时间戳排序的所有更新;
~~~

>3. 负载倾斜与消除热点
~~~
    场景:某个人名人发布一条状态, 这个事件可能导致大量写入同一个键;
    策略:
        在主键的开始或者是结尾添加一个随机数(一个两位数的十进制随机数就可以将主键分散为100钟不同的主键,从而存储在不同的分区中);
    缺点:
        任何读取都必须要做额外的工作,因为他们必须从所有100个主键分布中读取数据并将其合并。此技术还需要额外的记录,需要一些方法来跟踪哪些键需要被分割。
~~~

>4. 分片和次级索引
- 如果涉及次级索引, 情况将更加复杂;

#### **69. 数据库主从同步数据一致性如何解决？技术方案的优劣势比较**
`DDIA shard章有讲`

#### **89. 分库分表后如何部署上线**