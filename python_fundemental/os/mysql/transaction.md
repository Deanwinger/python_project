# MySQL_TRANSACTION
`事务相关`


#### **3. innodb的两阶段锁定协议是什么情况？**
`DDIA 第七章事务两阶段锁定`
- 在数据库系统领域，并发控制机制主要有两种，即锁和多版本机制。

- 两阶段锁
~~~
    1. 是一种所谓的悲观并发控制机制(pessimistic):它是基于这样的原则:如果有事情可能出错(如另一个事务所持有的锁所表示的),最好等到情况安全后再做任何事情。这就像互斥,用于保护多线程编程中的数据结构;

    2. 只要没有写入, 就允许多个事务同时读取同一个对象, 但对象只要有写入, 就需要独占访问的权限:
        a. 如果事务A读取了一个对象, 如果事务B想要写入该对象, 那么B必须要等到A提交或者是中止时才能继续;
        b. 如果事务A写入一个对象, 并且事务B想要对取, 则B必须等到A提交或者是中止才能继续;
~~~

#### **10. 数据库的隔离级别，一定会产生幻读吗？怎么解决**

`DDIA 第七章事务, 全章总结 -- 记住每个阶段对应的例子即可`
- 事务: 事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式;

- 四种隔离级别(参考第49题)


#### **49. 四种隔离级别**
>1. read uncommitted（读未提交)
~~~
    1. 它可以防止脏写，但不防止脏读
    2. 事务中的修改, 即使没有提交, 对其他事务都是可见的, 称之为脏读;
    3. 实际中非常少用;
~~~
    
>2. read commited （提已交读）== 不可重复读 -- 参考第50题
~~~
    1. 满足隔离性的简单定义：一个事务开始时，只能看见已经提交的事务的所做的修改，也就是说，一个事务从开始到提交之前，所做的任何改变对其他的事务是不可见的， 也叫“不可重复读”， 因为两次执行同样的查询，可能得到不一样的结果；

    2. 又被称为: 
~~~
    
>3. repeatable read (可重复读) == 快照隔离 -- 参考第51题
~~~
    1. 每个事务都从数据库的一致快照(consistent snapshot)中读取——也就是说,事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改,每个事务也只能看到该特定时间点的旧数据;

    2. 快照隔离对长时间运行的只读查询(如备份和分析)非常有用;
~~~

>4. serialization （可串行化）
    - 会在读取的每一行数据上都加锁； 最高级别，强制事务串行执行，避免了幻读的问题;


#### **50. 读已提交(不可重复读)**
~~~
    术语解释：
        脏写：如果两个事务同时尝试更新数据库中的相同对象，我们通常认为后面的写入会覆盖前面的写入。但是，如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作脏写
~~~

>1. 它提供了两个保证：

    （1）从数据库读时，只能看到已提交的数据（没有脏读）
        a.防脏读原因:
            - 可能只看到部分数据更新, 以邮件+未读邮件计数器为例;
            - 事务可能回滚;

    （2）从数据库写时，只会覆盖已写入的数据（没有脏写）
        a. 脏写可能存在的例子:
            - DDIA P206  

>2. 实现读已提交：

    （1）防止脏写，最常见的情况是：数据库通过使用“行锁”来防止脏写：当事务想要修改特定对象，它必须首先获得该对象的锁，然后必须持有该锁直到事务被提交或者中止，一次只有一个事务可以持有任何给定对象的锁；如果另一个事务要写入同一个对象，必须等到第一个事务提交或者是中止后，才能获得该锁并继续；

    （2）防止脏读，对于写入的每个对象，数据库都会记住旧的已提交值，和当前写入的新值，当事务在正在进行时，任何其他读取对象的事务都会拿到旧值；

>3. 读已提交时可能发生的问题:
~~~
    (1). 示例 DDIA P207
    解决方法:
        快照隔离(可重复读)
~~~

#### **51. 可重复读(快照隔离)**
>1. 实现快照隔离:
~~~
    (1). 与读已提交类似, 快照隔离使用写锁来防止脏写;
    (2). 关键原则: 读不阻塞写, 写不阻塞读;
    (3). 为实现快照隔离, 数据库保留着一个对象的几个不同的提交版本, 这种技术被称为多版本并发控制(MVCC); 
    (4). 支持快照隔离的存储引擎通常也使用MVCC实现读已提交, 读已提交实际上就是保存了同一个对象的两个版本;
    (5). 具体过程:
        a. 当一个事务开始时, 它被赋予一个唯一的, 永远增长的事务ID, 每当事务向数据库写入任何内容时, 它所写入的数据都会被标记上写入者的事务ID;
        b. 一致性快照的可见性规则;
        C. 索引和快照隔离;
        d. 可重复读与命名混淆;
~~~

>2. 丢失更新
- 解决方案
~~~
    1. 原子写： 原子操作通常通过在读取对象时，获取其上的排他锁来实现，这种技术有时也被称作游标稳定性；
    2. 显示锁定：
    3. 自动检测丢失的更新: 原子操作和锁是通过强制读取-修改-写入序列按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列。
    4. 比较并设置（CAS）：只有当前值从上次读取时一直没有改变，才允许更新发生，如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取-修改-写入序列；
~~~

#### **52. 可序列化**
>1. 可序列化：
- 读已提交和快照隔离级别会阻止某些竞争条件，但不会阻止另一些, 例如, 写入偏差和幻读
    ~~~
        0. 丢失更新
            a. 对应单一对象, 比如计数器

        1. 写入偏差
            a. 对应多对象, 医生值班的例子

        2. 幻读 -- 导致写入偏差的罪魁祸首
            - 一个事务中的写入改变另一个事务的搜索查询的结果,被称为幻读
            a. 支付,体现, 余额
    ~~~
- 通常被认为是最强的隔离级别，它保证即使事务可以并行执行，最终的结果与连续挨个执行一样，也就是说数据库可以防止所有可能的竞争条件；


#### **73. Mysql中事务ACID实现原理**
`https://www.cnblogs.com/rjzheng/p/10841031.html`
- 事务就是一组原子性的sql查询，或者说是一个独立的单元；

- start transaction 开始一个事务，事务中的所有读写操作被视为单个操作来执行, 要么使用commit，要么使用Rollback撤销；
~~~
    - A 原子性：一个事务必须被视为一个不可分割的最小单位，要么全部执行，要么全部不执行；

    - C 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态（两个账户之间的balance不会失衡）；

    - I 隔离性：同时执行的事务是相互隔离的，一个事务在提交前，对其他事务是不可见的；

    - D 持久性：一旦事务提交，则其所做的修改会永久的保存在数据库中；
~~~

- 实现原理
    >原子性: 能够再错误时中止事务, 丢弃所有部分更新的内容, 恢复到事务开始之前状态的能力;
    ~~~
        实现靠的是Innodb的undo log。
        undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
        例如
            (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
            (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
            (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作
        undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
    ~~~

    > 一致性:


#### **93. 事务的二段提交**
`DDIA`--第九章?