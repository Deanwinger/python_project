# MySQL_TRANSACTION
`事务相关`


> ### **1. Mysql中事务ACID实现原理**
`TO BE FINISHED`
`https://www.cnblogs.com/rjzheng/p/10841031.html`
- 事务就是一组原子性的sql查询，或者说是一个独立的单元；

- start transaction 开始一个事务，事务中的所有读写操作被视为单个操作来执行, 要么使用commit，要么使用Rollback撤销；
~~~
    - A 原子性：一个事务必须被视为一个不可分割的最小单位，要么全部执行，要么全部不执行；

    - C 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态（两个账户之间的balance不会失衡）；

    - I 隔离性：同时执行的事务是相互隔离的，一个事务在提交前，对其他事务是不可见的；

    - D 持久性：一旦事务提交，则其所做的修改会永久的保存在数据库中；
~~~

- 实现原理
    - 原子性: 能够再错误时中止事务, 丢弃所有部分更新的内容, 恢复到事务开始之前状态的能力;
    ~~~
        实现靠的是Innodb的undo log。
        undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
        例如
            (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
            (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
            (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作
        undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
    ~~~

    - 一致性:




> ### **2. 四种隔离级别**
- (1).read uncommitted（读未提交)
    - 概述:
    ~~~
        1. 它可以防止脏写，但不防止脏读
        2. 实际中非常少用;  
    ~~~
    
- (2).read commited(读已提交)
    
- (3).repeatable read (可重复读) == 快照隔离

- (4). serialization （可串行化）




> ### **3. 读已提交(不可重复读)**
- 概述:
~~~
    1. 满足隔离性的简单定义：一个事务开始时，只能看见已经提交的事务的所做的修改，也就是说，一个事务从开始到提交之前，所做的任何改变对其他的事务是不可见的， 也叫“不可重复读”， 因为两次执行同样的查询，可能得到不一样的结果；

    2.最基本的事务隔离级别,它提供了两个保证:
        1.从数据库读时,只能看到已提交的数据(没有脏读(dirty reads))
        2.写入数据库时,只会覆盖已经写入的数据(没有脏写(dirty	writes))               
~~~
- 实现读已提交
~~~
    1. 最常见的情况是--数据库通过使用行锁(row-level lock)来防止脏写:当事务想要修改特定对象(行或文档)时,它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定对象的锁;如果另一个事务要写入同一个对象,则必须等到第一个事务提交或中止后,才能获取该锁并继续。这种锁定是的数据库自动完成的

    2.大多数数据库防止脏读:对于写入的每个对象,数据库都会记住旧的已提交值,和由当前持有写入锁的事务设置的新值。当事务正在进行时,任何其他读取对象的事务都会拿到旧值。只有当新值提交后,事务才会切换到读取新值。
~~~
- 仍然存在的问题
~~~
    1. 读偏差: 一个事务中读取两次结果可能不同(图7-6的例子背下)
    进行备份需要复制整个数据库,对大型数据库而言可能需要花费数小时才能完成。备份进程运行时,数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。如果从这样的备份中恢复,那么不一致(如消失的钱)就会变成永久的。
~~~




> ### **4. 可重复读(快照隔离)**
- 概述:
~~~
    每个事务都从数据库的一致快照(consistent snapshot)中读取——也就是说,事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改,每个事务也只能看到该特定时间点的旧数据

~~~
- 实现快照隔离:
~~~
    (1). 与读已提交类似, 快照隔离使用写锁来防止脏写;
    (2). 关键原则: 读不阻塞写, 写不阻塞读;
    (3). 为实现快照隔离, 数据库保留着一个对象的几个不同的提交版本, 因为它并排维护着多个版本的对象, 这种技术被称为多版本并发控制(MVCC); 
    (4). 支持快照隔离的存储引擎通常也使用MVCC实现读已提交, 读已提交实际上就是保存了同一个对象的两个版本;
    (5). 具体过程:
        a. 当一个事务开始时, 它被赋予一个唯一的, 永远增长的事务ID, 每当事务向数据库写入任何内容时, 它所写入的数据都会被标记上写入者的事务ID;
        b. 一致性快照的可见性规则(下面有详述);
        C. 索引和快照隔离;
~~~
- 观察一致性快照的可见性规则
~~~
    1.在每次事务开始时,数据库列出当时所有其他(尚未提交或中止)的事务清单,即使之后提交了,这些事务的写入也都会被忽略。
    2.被中止事务所执行的任何写入都将被忽略。
    3.由具有较晚事务ID(即,在当前事务开始之后开始的)的事务所做的任何写入都被忽略,而不管这些事务是否已经提交。
    4.所有其他写入,对应用都是可见的。
~~~
- 仍然存在的问题
    - 对单对象而言 -- 丢失更新
        - 例子
        ~~~
            1.增加计数器
            2.更新账户余额
        ~~~
        - 解决方案
        ~~~
            1. 原子写： 
                a.原子操作通常通过在读取对象时，获取其上的排他锁来实现，这种技术有时也被称作游标稳定性；
                b.一个选择是简单地强制所有的原子操作在单一线程上执行
            2. 显示锁定：
            3. 自动检测丢失的更新: 原子操作和锁是通过强制读取-修改-写入序列按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列。
            4. 比较并设置（CAS）：只有当前值从上次读取时一直没有改变，才允许更新发生，如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取-修改-写入序列,但是,如果数据库允许从旧快照中读取,则此语句可能无法防止丢失更新；
        ~~~  

    - 对多对象而言 -- 写偏差
        - 例子
        ~~~
            1.两医生on call
            2.会议室预定
            3.抢注用户名
            4.账户的双重开支
        ~~~
        - 导致原因:
        ~~~
            幻读: 一个事务中的写入改变另一个事务的搜索查询的结果
            通用模式:
                a. 一个SELECT查询找出符合条件的行;
                b. 按照第一个查询的结果,应用代码决定是否继续;
                c. 如果应用决定继续操作,就执行写入(插入、更新或删除), 并提交事务。
        ~~~
        - 解决方案
        ~~~
            1. 可序列化
        ~~~




> ### **5. 可序列化**
- 可序列化：




#### **6. innodb的两阶段锁定协议是什么情况？**
`DDIA 第七章事务两阶段锁定`
- 在数据库系统领域，并发控制机制主要有两种，即锁和多版本机制。

- 两阶段锁
~~~
    1. 是一种所谓的悲观并发控制机制(pessimistic):它是基于这样的原则:如果有事情可能出错(如另一个事务所持有的锁所表示的),最好等到情况安全后再做任何事情。这就像互斥,用于保护多线程编程中的数据结构;

    2. 只要没有写入, 就允许多个事务同时读取同一个对象, 但对象只要有写入, 就需要独占访问的权限:
        a. 如果事务A读取了一个对象, 如果事务B想要写入该对象, 那么B必须要等到A提交或者是中止时才能继续;
        b. 如果事务A写入一个对象, 并且事务B想要对取, 则B必须等到A提交或者是中止才能继续;
~~~




#### **7. 分布式事务的两阶段提交**
`DDIA第九章`







## 二.相关问题


#### **1.什么是脏读, **
- 脏读
~~~
    - 定义：如果一个事务已经将一些数据库写入数据，但是事务还没有正式的提交或者是终止，如果另一个事务能看到未提交的数据, 那就叫做脏读(违反隔离性)；
    - 没有脏读， 从数据库读的时候，只能看到已提交的数据,意味着事务的任何写入操作只有在该事务提交时才能被其他人看到；

~~~
- 防止脏读的原因
~~~
    - 如果事务要更新多个多想，脏读意味着另一个事务可能只看到一部分的更新， 可能导致其他事务作出错误的决定；
    - 如果事务中止，则所有的数据需要回滚，脏读导致看到错误的数据；
~~~




#### **2. 什么是脏写**
- 脏写
~~~
    - 覆盖了一个尚未提交的写入, 称为脏写:
        - 脏写： 如果两个事务同时尝试更新数据库中的对象， 会发生什么情况，我们不知道写入的顺序是怎样的，但是我们通常认为后面的写入会覆盖前面的写入， 如果先前的写入是尚未提交事务的一部分，后面的写入会覆盖一个尚未提交的值，这样被称为脏写；
    - DDIA 图7.5的例子（脏写导致不好的例子），车子卖给了Bob， 但是账单寄给了Alice的例子就是脏写
~~~
- 防止脏写
~~~
    - 通常是延迟第二次写入，直到第一次写入事务提交或者是中止为止；
~~~

#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**