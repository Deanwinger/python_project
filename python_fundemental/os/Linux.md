# Linux相关的问题

## 题目合集

### **1. 介绍select, poll， epoll，信号驱动IO，以及他们的区别**

`概述`

- 上述锁提到的都是用来实现一个目标：同时检查多个文件描述符，看他们是否准备IO（准确的说，是看IO系统调用是否可以非阻塞的执行）；

~~~
    (1). IO多路复用允许进程同时检查多个文件描述符，以找出他们中的任何一个是否可执行IO操作，系统调用select()和poll()用来执行IO多路复用；
    (2). 信号驱动IO，是指当有输入或者数据可以写到指定的文件描述符时，内核向请求数据的进程发送一个信号，在此之前，进程可以处理其他的任务，当IO操作可以执行时通过接受信号来获得通知，当同时检查大量的文件描述符时， 信号驱动IO相比select()和poll()用来有显著的提升；
    (3).epoll API是Linux专有的特性，同IO多路复用一样，epoll API允许进程检查多个文件描述符，看其中任意一个是否能执行IO操作；

    - IO多路复用优势在于可移植性，主要缺点是当需要检查大量的文件描述符时，性能延展性不佳；
    - epoll的关键优势在于能让应用程序高效的检查大量的文件描述符，主要的缺点是专属于Linux系统的API；
    - epoll 相对于信号驱动IO的优势：
        a. 避免了信号处理的复杂性；
        b. 可以指定想要检查的事件类型；
        c. 可以选择水平触发或者边缘触发的形式来通知进程；
~~~

`比较select， poll`
`Linux 系统编程手册63.2.4`

- 要如何指定待检查的文件描述符：
    - select中，有三个集合，在每个集合中标明我们感兴趣的文件描述符；
    - poll中，提供一系列文件描述符，并在每个文件描述符上标明我们感兴趣的事件；

- 区别
    (1).select()所使用的数据类型fd_set对于被检查的文件描述符数量有一个上限限制（FD_SETSIZE）,在linux 下，上限值默认1024， poll没有限制，
    (2).由于select的参数fd_set同时也是保留调用结果的地方，要是循环反复调用的话，我们必须每次都重新初始化fd_set，而poll通过独立的两个字段，events和revents来处理，从而避免每次都重新初始化；
    (3). select提供的超时精度比poll高；
    (4). select 比poll使用的更加广泛；
    (5). 当需要检查的描述符集合很稀疏时，poll性能更佳；

- 存在的问题
    - 每次调用，内核都必须检查所有被指定的文件描述符，当文件描述符太多的时候，影响效率；
    - 每次调用，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，内核检查过后，修改这个数据结构并返回给程序；对poll来说，随着待检查的描述符的数量增加，传递给内核的数据结构也会随之增加，而从用户空间到内核空间来回拷贝这个数据结构，将占用大量的CPU时间。对于select来说，这个数据结构的大小固定为FD_SETSIZE，与待检查的文件描述符数量无关；
    - select和poll调用完成之后，程序必须检查返回的数据结构中每个元素，一次查明哪个文件描述符处于就绪态了；

`信号驱动IO`
`epoll`
`epoll与IO多路复用`
 

### **2. 介绍边缘触发，水平触发， 以及他们的区别**

- 1. 两种文件描述符准备就绪的通知模式：

    - 水平触发通知：如果文件描述符上可以非阻塞地执行IO系统调用，此时认为它已经就绪；
    - 边缘触发通知：如果文件描述符自上次状态检查以来有了新的IO活动，此时需要触发通知；

~~~
    水平触发：IO多路复用， epoll；
    边缘触发: 信号驱动IO， epoll；
~~~

- 2. 通知模式如何影响设计程序的方式：
    - 采用水平触发时，我们可以采用任意时刻检查文件描述符的就绪状态，由于水平触发允许我们在任意时刻重复检查IO状态，不需要当文件描述符就绪后尽可能多的执行IO；
    - 采用边缘触发时，只有当IO事件发生时，我们才会收到通知，所以会尽可能多的执行IO；

### 3. 进程和线程的联系与区别, 内核级线程与用户级线程

- 操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，在这种模型下，内核调度的基本单位是线程而非进程，进程只需要负责管理资源，这些资源则由同一进程下的线程共享（内存空间, 文件描述符，信号处理器等），但是寄存器、栈、程序计数器等不共享。

- 创建、终止、切换thread的开销要比process小的多；由于共享地址空间，线程通信比进程通信高效得多



### 4. 线程之间的一些同步技术，如互斥体、信号量、条件变量, 文件锁

### 5. 进程之间的一些同步技术，如互斥体、信号量、条件变量, 文件锁

### 6. 条件变量内部有锁，为什么在wait条件变量时，最外层还需要加锁

### 7. 除了notify，wait还有什么情况下可能被唤醒

### 8.什么是死锁、如何避免死锁(死锁的条件及银行家算法、资源分配图之类的)
- 死锁

### 9. 多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？

### 10.进程之间通信的常用技术也需要掌握，常用的通信方式（linux下）有共享内存、匿名和具名管道、socket、消息队列等等，（管道和socket是两个必须深入掌握的考察点）
- 种类
~~~
    1. 数据传输
        a. 管道
        b. FIFO
        c. socket
        d. 消息队列

    2. 共享内存
        a. posix 共享内存
        b. 内存映射
~~~

### 11. 什么是daemon进程，如何产生daemo进程，什么是僵尸进程，僵尸进程如何产生和消除

`1. 什么是daemon进程` -- linux 编程手册37章
- 守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，syslogd 就是指管理系统日志的守护进程

`2. 如何产生daemon进程`
- 步骤：
~~~
    1. 
~~~

`3. 什么是僵尸进程` -- Linux 编程手册26章
~~~
    在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。

    僵尸进程和孤儿进程的区别是，孤儿进程是子进程还在运行，而父进程挂了，子进程被init进程收养。僵尸进程是父进程还在运行但是子进程挂了，但是父进程却没有使用wait来清理子进程的进程信息，导致子进程虽然运行实体已经消失，但是仍然在内核的进程表中占据一条记录,并导致进程号一直被占用, 而系统能使用的进程号数量是有限的(可以用ulimit查看相关限制), 如果产生大量僵尸进程的话, 将因为没有可用的进程号而导致系统不能产生新的进程
~~~

`4. 僵尸进程如何产生和清除`
~~~
    (1)改写父进程，在子进程死后要为它收尸。具体做法是接管SIGCHLD信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行 waitpid()函数为子进程收尸。

    (2)把父进程杀掉,父进程死后，僵尸进程成为"孤儿进程"，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失

    (3)重启系统
~~~

### 12. 查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；
`http://man.linuxde.net/`
- ps -ef | grep $$ ($$ 代表当前进程的PID)
~~~
    - lsof
    - uniq
    - wc | ls | cp | mv | rm
    - scp
    - ssh
    - grep
    - awk 见P19
    - sed 见P67
    - more | less | touch | vim
        more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件, less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向后移动，而且 less 在查看之前不会加载整个文件
    - who
    - man
    - pwd
    - netstat ???
    - echo
    - nohup
    - strace
    - curl
    - tcpdump
    - top
    - chmod
~~~

### 13. Linux目录结构（尤其是/proc非常重要）以及硬链接和软连接区别
`Linux 系统编程手册第18章`（需要先看14章）

### 14. kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）

### 15. 使用什么命令查看cpu和内存情况（如查看内存使用、网络情况）

### 16. 管道的使用

### 17. grep的使用，一定要掌握，每次都会问在文件中查找

### 18. find命令

### 19. awk使用

### 20. Linux对内存进行操作的命令；

### 21. 操作系统进行文件操作，都会需要什么步骤

### 22. 本机socket需要经过协议栈解包吗

### 23. 全局变量、静态存储在进程地址空间的哪里；

### 24. 堆和栈的区别，什么时候在栈中什么时候在堆中，栈的结构，栈的细节要搞的特别清楚，一些对技术要求高的公司会问的深入

`为什么系统中要分为heap（堆）和stack（栈）? https://www.zhihu.com/question/281940376/answer/425658338`


### 25. 如何查看系统性能,性能指标， 查看cpu负载，一般为多少，过高怎么解决

### 26. 消息队列同时消费问题

### 27. 请简述操作系统内存管理, 段式与页式内存管理的优缺点(顺道讲了下段页式)

### 28. 谈谈什么是面向对象

### 29. 策略模式
`fluent Python 策略模式改写案例`

### 30. 有多少种类型的缓存,从客户端到服务端

### 31. sql注入是怎么产生的，如何防止？
- 常见攻击方式
~~~
    一般说来，在Web安全领域，常见的攻击方式大概有以下几种：
    1、SQL注入攻击
        a. 凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕
        b. 1、检查变量数据类型和格式: 只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式
    2、跨站脚本攻击 - XSS
    3、跨站伪造请求攻击 - CSRF
    4、文件上传漏洞攻击
    5、分布式拒绝服务攻击 - DDOS
~~~

### 32. xss如何预防？htmlescape后能否避免xss? 

### 33. csrf是什么？django是如何防范的？

### 34. 什么是分组加密？加密模式有哪些？ecb和cbc模式有什么区别？为什么需要iv向量？

### 35. 

### 36. 

### 37. 如何生成共享秘钥？ 如何防范中间人攻击？

### 38. 生产者消费者模型应用场景及优势？

### 39. 什么是rpc及应用场景？

### 40. 安全相关
- 防范常见的xss，csrf，sql注入等攻击，不要信任来自外部的任何输入。对于外部接收的参数都要过滤，比如表单，对外的 api 等。对内的函数无需每一层都加上参数过滤（基于约定或者规范编程，没有遵守约定抛出的异常由调用者负责处理）。 有一个例外就是数据库查询的参数，最好经过一次参数校验，防止不合理参数造成慢查询等问题。或者简单一些就直接使用断言

###**41. 解释struct的字节对齐，为什么要对齐，如何实现两个结构体的比较相等，可以用compar()按字节比较吗**

###**42. 云上传是怎么实现秒传的**
###**43. 安全相关的问题**
`https://zhuanlan.zhihu.com/p/20336461`


###**44. 共享内存的地址是否连续，物理内存是什么时候分配的，如何通知另一个进程内存更改**
`Linux 系统编程手册48和54章`
###**45. 查看当前哪些进程占用了8080端口**
- lsof
###**46. 多线程线程安全**
`Linux 系统编程手册31章`

###**47. 两个线程一个只打印奇数，另一个只打印偶数，怎么能打印出连续的数**
###**48. 用户态和内核态**
###**49. git的 pull 、 push 和 merge的联系和区别**
###**50. 负载均衡的算法**
###**51. 哈弗曼编码,如何解决译码问题**
###**52. 如何把文件从服务器复制到本地,用什么命令**
- scp
###**53. 如何确保单例线程安全**
###**54. 系统负载**
###**55. 如何查看进程的线程情况top -H -p**
###**56. 对称加密与非对称加密**
###**57. Linux文件系统实现, 查看文件大小的命令 **
`Linux 系统编程手册14章`
###**58. 缺页操作系统如何处理**
`csapp 印象中有涉及`
###**59. RPC实现**
###**60. 赛马问题，36匹马，6个赛道，找出最快6匹马的最小赛马次数，如果是n匹马，m个赛道呢**
#### **61. 操作系统调度算法**
#### **62. **
#### **63. linux中断响应机制**
#### **64. 虚拟内存机制**
#### **65. 动态代理原理和实现，画出代理模式UML**
#### **66. 进程中文件写怎么保证安全？**
#### **67. sed**
#### **68. awk**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**
#### **.**