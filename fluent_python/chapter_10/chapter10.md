# 序列的修改、散列和切片


- 本章将以第 9 章定义的二维向量 Vector2d 类为基础,向前迈出一大步,定义表示多维向量的 Vector 类:

~~~
    - 基本的序列协议--`__len__`和`__getitem__`
    - 正确表述拥有很多元素的实例
    - 适当的切片
    - 综合各个元素的值计算散列值
    - 自定义的格式语言拓展
    - 通过`__getattr__`方法实现属性的动态存取
~~~

### 10.1 Vector类:用户定义的序列类型

- pass

### 10.2 Vector类第1版:与Vector2d类兼容

### 10.3 协议与鸭子类型

- 在Python中创建功能完善的序列类型无需使用继承，只要符合序列协议的方法；Python的序列协议只需要__len__ 和 __getitem__两个方法

### 10.4 Vector类第二版： 可切片的序列

- 内置的序列类型,切片得到的都是各自类型的新实例,而不是其他类型。为了把 Vector 实例的切片也变成 Vector 实例,我们不能简单地委托给数组切片。我们要分析传给 __getitem__ 方法的参数,做适当的处理。

#### 10.4.1 切片原理

- P433 的例子非常值得一看

#### 10.4.2 能处理切片的__getitem__方法

### **10.5 动态存储属性**

- P438 的示例10-8 非常值得一看

- 属性查找失败后,解释器会调用 __getattr__ 方法。简单来说,对my_obj.x 表达式,Python 会检查 my_obj 实例有没有名为 x 的属性;如果没有,到类(my_obj.__class__)中查找;如果还没有,顺着继承树继续查找。 4 如果依旧找不到,调用 my_obj 所属类中定义的__getattr__ 方法,传入 self 和属性名称的字符串形式(如 'x')。

### **10.6 散列和快速等值测试**

### **10.7 vector类d五版：格式化**

