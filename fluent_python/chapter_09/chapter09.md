# 符合Python风格的对象


##### 本章包含以下话题:
- 支持用于生成对象其他表示形式的内置函数(如repr()、bytes(),等等)
- 使用一个类方法实现备选构造方法
- 扩展内置的 format() 函数和 str.format() 方法使用的格式微语言
- 实现只读属性
- 把对象变为可散列的,以便在集合中及作为dict的键使用利用 __slots__ 节省内存

## 9.1 对象表示形式
1. 获取对象的字符串表现形式
~~~
repr()
  以便于开发者理解的方式返回对象的字符串表示形式。
str()
  以便于用户理解的方式返回对象的字符串表示形式
~~~

## 9.2 再谈向量类
 - 见文件vector2d_v0.py

## 9.3 备选构造方法
 - A Alternative Constructor

## 9.4 classmethod与staticmethod
1. classmethod: 定义，操作类而不是操作实例的方法。classmethod改变了调用方法的方式,因此类方法的第一个参数是类本身,而不是实例。classmethod最常见的用途是定义备选构造方法。见P392示例
2. staticmethod装饰器也会改变方法的调用方式,但是第一个参数不是特殊的值。其实,静态方法就是普通的函数,只是碰巧在类的定义体中,而不是在模块层定义。

## 9.5 格式化显示
1. 内置的 format() 函数和 str.format() 方法把各个类型的格式化方式委托给相应的 .__format__(format_spec) 方法。format_spec 是格式说明符,它是:
    - format(my_obj, format_spec) 的第二个参数,或者
    - str.format() 方法的格式字符串,{} 里代换字段中冒号后面的部分
~~~
>>> brl = 1/2.43 # BRL到USD的货币兑换比价
>>> brl
0.4115226337448559
>>> format(brl, '0.4f')
'0.4115'
>>> '1 BRL = {rate:0.2f} USD'.format(rate=brl)
'1 BRL = 0.41 USD'
~~~
2. 如果类没有定义 `__format__` 方法,从 object 继承的方法会返回str(my_object), 然而,如果传入格式说明符,`object.__format__` 方法会抛出TypeError

## 9.6 可散列的Vector2d
  - 为了把 Vector2d 实例变成可散列的,必须使用 `__hash__` 方法，还需要 `__eq__` 方法, 为此,我们要把vector.x 和 vector.y 分量设为只读特性

## 9.7 Python的私有属性和“受保护的”属性
1. 名称改写
举个例子。有人编写了一个名为 Dog 的类,这个类的内部用到了 mood实例属性,但是没有将其开放。现在,你创建了 Dog 类的子类:Beagle。如果你在毫不知情的情况下又创建了名为 mood 的实例属性,那么在继承的方法中就会把 Dog 类的 mood 属性覆盖掉。这是个难以调试的问题。为了避免这种情况,如果以 `__mood` 的形式(两个前导下划线,尾部没有或最多有一个下划线)命名实例属性,Python 会把属性名存入实例的`__dict__` 属性中,而且会在前面加上一个下划线和类名。因此,对Dog 类来说,`__mood` 会变成 `_Dog__mood`;对 Beagle 类来说,会变成`_Beagle__mood`。这个语言特性叫名称改写(name mangling)。

2. 有些人不喜欢这种句法,他们约定使用一个下划线前缀编写“受保护”的属性(如 self._x)， Python 解释器不会对使用单个下划线的属性名做特殊处理,不过这是很多 Python 程序员严格遵守的约定,他们不会在类外部访问这种属性

## 9.8 使用 __slots__ 类属性节省空间
1. 基本性质
  - 默认情况下， Python在各个实例中名为`__dict__`的字典存储实例属性；
  - 定义 `__slots__` 的方式是,创建一个类属性,使用 `__slots__` 这个名字,并把它的值设为一个字符串构成的可迭代对象,其中各个元表示各个实例属性，在类中定义 `__slots__` 属性的目的是告诉解释器:“这个类中的所有实例属性都在这儿了!”
  - 处理列表数据时 `__slots__` 属性最有用,例如模式固定的数据库记录,以及特大型数据集。

2. `__slots__` 的问题
  - 每个子类都要定义 `__slots__` 属性,因为解释器会忽略继承的`__slots__` 属性。
  - 实例只能拥有 `__slots__` 中列出的属性,除非把 `__dict__` 加入 `__slots__` 中(这样做就失去了节省内存的功效)。
  - 如果不把 `__weakref__` 加入 `__slots__`,实例就不能作为弱引用的目标。

3. tips:
  - 如果你的程序不用处理数百万个实例,或许不值得费劲去创建不寻常的类,那就禁止它创建动态属性或者不支持弱引用。与其他优化措施一样,仅当权衡当下的需求并仔细搜集资料后证明确实有必要时,才应该使用 `__slots__` 属性。

## 9.9 覆盖类属性
1. 覆盖类属性
  - Python 有个很独特的特性:类属性可用于为实例属性提供默认值；
  - P414的例子非常值的一看；
